\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts, mathtools}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
\usepackage{minted}

\hypersetup{
    colorlinks,
    linkcolor={blue!80!black},
    citecolor={blue!80!black},
    urlcolor={blue!80!black}
}

\colorlet{LightGray}{White!90!Periwinkle}
\colorlet{LightOrange}{Orange!15}
\colorlet{LightGreen}{Green!15}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\bN}{\bb{N}}

\newcommand{\lo}{\mathrm{lo}}

\declaretheoremstyle[name=Theorem,]{thmsty}
\declaretheorem[style=thmsty,numberwithin=section]{theorem}
\tcolorboxenvironment{theorem}{colback=LightGray}

\declaretheoremstyle[name=Proposition,]{prosty}
\declaretheorem[style=prosty,numberlike=theorem]{proposition}
\tcolorboxenvironment{proposition}{colback=LightOrange}

\declaretheoremstyle[name=Principle,]{prcpsty}
\declaretheorem[style=prcpsty,numberlike=theorem]{principle}
\tcolorboxenvironment{principle}{colback=LightGreen}

\setstretch{1.2}
\geometry{
    textheight=9in,
    textwidth=5.5in,
    top=1in,
    headheight=12pt,
    headsep=25pt,
    footskip=30pt
}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		notes on \LARGE \textbf{\uppercase{The Little Typer}
		\HRule{2.0pt} \\ [0.6cm] \LARGE{CSC392} \vspace*{10\baselineskip}}
		}
\date{}
\author{\textbf{Mustafa Motiwala} \\ 
		1009298868}

\maketitle
\newpage

\tableofcontents
\newpage

% ------------------------------------------------------------------------------

\section{The More Things Change, the More They Stay the Same}
\subsection{Summary}
This chapter introduces terminology, focusing on \textit{judgements} (propositional statements of a specific shape), \textit{expressions} (every well-formed statement about which it makes sense to make judgements), and \textit{types}.

\subsection{The \ttt{Atom} type}
\begin{itemize}
    \item infinitely many constructors! (each atom constructs itself)
    \item an atom is a tick-mark followed by a sequence of letters and hyphens
    \begin{itemize}
        \item \ttt{'a, 'b, 'a-b-c} are atoms
        \item \ttt{'0, 'a0, ', ''} are \textbf{not} atoms
    \end{itemize}
\end{itemize}

\subsection{Judgements}
\begin{itemize}
    \item Has \textbf{four} forms
        \begin{enumerate}
            \item \underline{\phantom{blank}} is a \underline{\phantom{blank}}.
                \begin{itemize}
                    \item \ttt{'a} is a \ttt{Atom}.
                    \item \ttt{'0} is a \ttt{Atom} (not true but still a judgement).
                \end{itemize}
            \item \underline{\phantom{blank}} is the same \underline{\phantom{blank}} as \underline{\phantom{blank}}.
                \begin{itemize}
                    \item \ttt{'a} is the same \ttt{Atom} as \ttt{'a}.
                    \item \ttt{'b} is the same \ttt{Atom} as \ttt{(cdr (cons 'a 'b))}.
                \end{itemize}
            \item \underline{\phantom{blank}} is a type.
                \begin{itemize}
                    \item \ttt{Atom} is a type.
                    \item \ttt{(Pair Atom Atom)} is a type.
                \end{itemize}
            \item \underline{\phantom{blank}} and \underline{\phantom{blank}} are the same type.
                \begin{itemize}
                    \item \ttt{Atom} and \ttt{Atom} are the same type.
                \end{itemize}
        \end{enumerate}
    \item Can be believable (true) or not believable (false).
    \item Some judgements require other judgements (i.e, presuppositions) to even make sense.
        \begin{itemize}
            \item the judgment ``\ttt{'a} is the same \ttt{'b} as \ttt{'c}" requires first the judgement that ``\ttt{'b} is a type"
        \end{itemize}
\end{itemize}

\subsection{Normal Forms}
\begin{itemize}
    \item The \textit{normal form} of an expression is ``the most direct" (\textcolor{red}{how can we formalize this?}) way of writing that expression.
    \item Allows us to define equality on expressions. Two expressions are the same if and only if their normal forms are the same.
        \begin{itemize}
            \item \textbf{Note:} Sameness is a judgement that is different for types and non-types.
            \item If expressions \(A\) and \(B\) are types, then they are the same type (judgement 4) iff their normal forms are identical.
            \item If expressions \(A\) and \(B\) are not types but are themselves described by a type \(T\) (judgement 1), then \(A\) and \(B\) are the same iff their normal forms (with respect to \(T\)) are identical.
        \end{itemize}
\end{itemize}

\subsection{Constructors \& Type Constructors}
\begin{itemize}
    \item A type is defined by describing its constructors; \textbf{constructor expressions are the direct ways of building expressions with that type}
        \begin{itemize}
            \item \ttt{zero} and \ttt{add1} are the constructors of the \ttt{Nat} type.
            \item \ttt{cons} is the constructor of \ttt{Pair} types.
            \item Each atom constructs itself.
        \end{itemize}
    \item type constructors construct types.
        \begin{itemize}
            \item \ttt{Pair} is a type constructor; \ttt{Pair} on its own is not a type - it needs two arguments to define a new type.
        \end{itemize}
\end{itemize}

\subsection{Values}
\begin{itemize}
    \item A value is an expression with a constructor at the top.
    \item Since constructor arguments do not have to be normal, not all values are normal.
    \item Finding a value of an expression is known as evaluation.
    \item Since values don't have to be normal, one expression can have multiple values.
    \item (\textbf{not in book}) normal forms (of non-type expressions) are values.
\end{itemize}

\subsection{Claims and Definitions}
\begin{itemize}
    \item We associate a name with an expression via \ttt{define}
    \begin{itemize}
        \item \ttt{(define two (add1 (add1 zero)))}
    \end{itemize}
    \item Names must first be given types via \ttt{claim} \textit{before defining}.
    \begin{itemize}
        \item \ttt{(claim two Nat)}
    \end{itemize}
    \item These are forever. Names can be \ttt{claim}ed and \ttt{define}d at most once.
\end{itemize}

\section{Doin' What Comes Naturally}
\subsection{Summary}
This chapter focuses heavily on \textit{eliminators} which are opposed to \textit{constructors} that are discussed in the previous chapter.
\\ \\
We discuss the \(\lambda\) constructor and its eliminator, the application operator (juxtaposition in Pie). The \ttt{which-Nat} eliminator for the \ttt{Nat} type is also introduced.
\\ \\
Recursion is not an option in Pie.
\\ \\
We also discuss the \(\mathcal{U}\) type, which is the type of types. Every \(\mathcal{U}\) is a type, but not every type is a \(\mathcal{U}\); this is because \(\mathcal{U}\) is a type but is not a \(\mathcal{U}\) (no type is itself).
\\ \\
Other trivial things like the semantics of function application (substitution), ``neutral" expressions (expressions with free variables), and more on pairs, \ttt{cons}, \ttt{car}, and \ttt{cdr}.
\subsection{Constructors and Eliminators}
\begin{itemize}
    \item Constructors \textit{build} values whereas Eliminators \textit{dismantle} values.
        \begin{itemize}
            \item \ttt{(cons 1 2)} builds a \ttt{(Pair Nat Nat)}; to then access the numbers \ttt{1} and \ttt{2} again, we use \ttt{car} and \ttt{cdr}.
            \item \ttt{(\(\lambda\) (s) s)} builds a \ttt{(\(\rightarrow\) Atom Atom)}; application is the eliminator for functions
        \end{itemize}
    \item The application eliminator for functions works by pure substitution. Hence, if \ttt{f} is a \ttt{(\(\rightarrow\) X Y)} then \ttt{(\(\lambda\) (y) (f y))} is the same \ttt{(\(\rightarrow\) X Y)} as \ttt{f} \textit{as long as \ttt{y} does not appear in \ttt{f}}. \textcolor{red}{Is this last condition really necessary in Pie, or have the authors introduced it just to make teaching the semantics of function application simpler?}
    \item The eliminator for \ttt{Nat} is \ttt{which-Nat} which takes a \ttt{Nat} \(k\), an expression which is returned if \(k = 0\) and a function \ttt{f} which, if \(k = \ttt{(add1 n)}\) is equal to \ttt{(f n)}. So, \[
        \ttt{(\(\lambda\) (k) (which-Nat k zero add1))}
    \]
    is a silly way of implementing the identity on \ttt{Nat}. \textcolor{red}{How do we write the type of \ttt{which-Nat}? What is the syntax for type variables?}
    \item \textbf{Note:} in languages like Haskell and Erlang that support pattern matching, it seems like we get eliminators built in to the syntax of the language. \textcolor{red}{How do Pie eliminators differ from pattern matching?}
\end{itemize}
\subsection{Type Values and the Universal Type \(\mathcal{U}\)}
\begin{itemize}
    \item \ttt{\(\mathcal{U}\)} is the universal type; it is the type of types.
    \item To define a type alias, we use \ttt{(claim alias \(\mathcal{U}\))} and \ttt{(define alias type-expr)}
        \begin{itemize}
            \item \ttt{(claim Predicate \(\mathcal{U}\))} and \ttt{(define Predicate (\(\rightarrow\) Nat Bool)}
        \end{itemize}
    \item Type constructors are parameterized types, such as \ttt{Pair} or \ttt{\(\rightarrow\)}.
    \item Type values are expressions with a type constructor at the top.
    \item Every \(\mathcal{U}\) is a type; but not all types are \(\mathcal{U}\) (in particular, \(\mathcal{U}\) is a type but not a \(\mathcal{U}\) because no type is itself)
\end{itemize}
\subsection{Equivalence of expressions}
\begin{itemize}
    \item Neutral expressions are those with free variables; identically written neutral expressions are always the same, regardless of type.
    \item The semantics of \ttt{claim} and \ttt{define} are as you'd expect; if \ttt{name} is \ttt{claim}ed to be an \ttt{X} and \ttt{define}d to be \ttt{expr}, then \ttt{name} is the same \ttt{X} as \ttt{expr}.
    \item \(\eta\)-equivalence; \ttt{f} is the same function as \ttt{(\(\lambda\) (x) (f x))}.
    \item If \ttt{p} is a \ttt{(Pair X Y)} then \ttt{p} is the same \ttt{(Pair X Y)} as \ttt{(cons (car p) (cdr p))}.
\end{itemize}
\section{Eliminate All Natural Numbers!}
\subsection{Summary}
This chapter is all about two new eliminators for \ttt{Nat}, \ttt{iter-Nat} and \ttt{rec-Nat}.
\\ \\
These solve the main problem with \ttt{which-Nat}, which is that it only eliminates one constructor at a time. That is, if \ttt{n = (add1 k)}, then \ttt{which-Nat} will eliminate the singular \ttt{add1} but will not eliminate \ttt{k}. In contrast, \ttt{iter-Nat} and \ttt{rec-Nat} will eliminate all the way down to \ttt{zero}.
\\ \\
\ttt{iter-Nat} takes a natural number \(n\), an initial value \(s\) of type \(X\), and a unary function \(f : X \to X\), and returns \(f^n(s)\) where \(f^n\) is the \(n\)-fold composition.
\\ \\
\ttt{rec-Nat} takes a natural number \(n\), an initial value \(s\), and a binary function \(f : \mathbb{N} \times X \to X\) and returns \[
    f(n - 1, f(n-2, f(\dots, f(0, s)\dots)))
\]
\subsection{Totality}
A function is \textit{total} if it assigns a value to every possible argument. Totality is built into the ``typical" notion of functions from mathematics, as a function \(f : A \to B\) is not a function if \(f(a)\) is not defined for some element \(a \in A\). In Pie, \textit{all functions are total.}
\subsection{The \ttt{iter-Nat} eliminator}
For \ttt{X} a type, \ttt{target} a \ttt{Nat}, \ttt{base} a \ttt{X}, and \ttt{step} a function from \ttt{X} to \ttt{X}, \[ E \coloneqq \ttt{(iter-Nat target base step)} \] is an \ttt{X}. If \ttt{target} is zero, then \(E\) is the same \ttt{X} as \ttt{base}. Otherwise, if \(E = \) \ttt{(add1 n)}, then \(E\) is the same \ttt{X} as \[
    \ttt{(step (iter-Nat n base step))}
\]
Intuitively, \ttt{iter-Nat} iterates the function \ttt{step} \ttt{target} times on \ttt{base}.
\subsection{The \ttt{rec-Nat} eliminator} \label{rec-nat-elim}
For \ttt{X} a type, \ttt{target} a \ttt{Nat}, \ttt{base} a \ttt{X}, and \ttt{step} a binary function of \ttt{Nat} and \ttt{X} to \ttt{X}, \[ E \coloneqq \ttt{(rec-Nat target base step)} \] is an \ttt{X}. If \ttt{target} is zero, then \(E\) is the same \ttt{X} as \ttt{base}. Otherwise, if \(E = \) \ttt{(add1 n)}, then \(E\) is the same \ttt{X} as \[
    \ttt{(step n (rec-Nat n base step))}
\]
\ttt{rec-Nat} achieves \href{https://en.wikipedia.org/wiki/Primitive_recursive_function}{primitive recursion} on the naturals. I don't really know what this means yet, but it looks cool!
\subsection{Superfluence of \ttt{which-Nat} and \ttt{iter-Nat} with respect to \ttt{rec-Nat}}
\ttt{rec-Nat} can be used to implement \ttt{which-Nat} and \ttt{iter-Nat} by using a function which ignores the second and first arguments respectively. That is, \[
    \ttt{(which-Nat n s f)} = \ttt{(rec-Nat n s (\(\lambda\) (n-1 \_) (f n-1)))}
\]
and \[
    \ttt{(iter-Nat n s f)} = \ttt{(rec-Nat n s (\(\lambda\) (\_ f-n-1) (f f-n-1)))}
\]
\subsection{Some notes on primitive recursion}
As mentioned in \autoref{rec-nat-elim}, the \ttt{rec-Nat} eliminator achieves primitive recursion.
\begin{itemize}
    \item 
        Primitive recursion \textbf{does not} yield every possible computable function. A cool counterexample is the \href{https://en.wikipedia.org/wiki/Ackermann_function}{Ackermann function} which is well-defined, total, and computable, but not primitive recursive. \textcolor{red}{Does this mean that the Ackermann function can not be defined in Pie? Does Pie have more constructs beyond \ttt{iter-Nat} capable of surpassing the computing power of primitive recursion?}
    \item
        An intuitive way of understanding the computing power of primitive recursion is via ``the computer language" definition. That is, primitive recursion has the same computing power as a programming language with arithmetic, conditionals, comparisons, and \textbf{bounded} loops.
    \item
        Clearly, \ttt{rec-Nat} allows us to define functions that depend only on their previous value. That is, if \(f : \mathbb{N} \to \mathbb{N}\) is a function such that \(f(n + 1)\) is defined in terms of \(f(n)\) only, then it is easy to implement this using \ttt{rec-Nat} (\textcolor{red}{Is this a sufficient condition for primitive recursion? Do there exist functions like this that are not primitive recursive?}) What if \(f\) depends on two or more previous values, such as the Fibonacci function? We can use something called \href{https://en.wikipedia.org/wiki/Course-of-values_recursion}{course of values recursion} to define these.
    \item
        As a concrete example of the above, here is how we might encode the function \(F : \bN \to \bN\) defined by \[
            F(n) = \begin{cases}
                        1 & n < 2 \\
                        F(n - 1) + F(n - 2) & n \geq 2
                   \end{cases}
        \]
        into a function \(g : \bN \to \bN\) so that \(g(n + 1)\) depends only on \(g(n)\). 
        \\ \\
        We define \(g(n) = 2^{F(n)}3^{F(n + 1)}\). Then, \(g(0) = 6\) and \begin{align*}
            g(n + 1) &= 2^{F(n + 1)}3^{F(n + 2)} \\
                     &= 2^{\lo(3, g(n))}3^{F(n + 1) + F(n)} \\
                     &= 2^{\lo(3, g(n))}3^{F(n + 1)} 3^{F(n)} \\
                     &= 2^{\lo(3, g(n))}3^{\lo(3, g(n))} 3^{\lo(2, g(n))}
        \end{align*}
        Here, the \(\lo(a, b)\) function gives the number of times \(b\) is divisible by \(a\). \hyperref[code:lo]{This function}, as well as \hyperref[code:exponentiation]{exponentiation} and \hyperref[code:multiplication]{multiplication} can be defined using primitive recursion, and so \(g\) can be defined using primitive recursion, and so \(F(n) = \lo(2, g(n))\) can be \hyperref[code:Fibonacci]{defined via primitive recursion}, and hence the Fibonacci function is primitive recursive!  
\end{itemize}
\section{Easy as Pie}
\subsection{Summary}
\subsection{The \(\Pi\) Operator}
\subsection{Superfluence of \(\to\) with respect to \(\Pi\)}

\appendix
\section{Some Cool Pie Code} \label{pie-code-appendix}
\input{code-listing}
\end{document}
