\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts, mathtools}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
\usepackage{minted}

\hypersetup{
    colorlinks,
    linkcolor={blue!80!black},
    citecolor={blue!80!black},
    urlcolor={blue!80!black}
}

\colorlet{LightGray}{White!90!Periwinkle}
\colorlet{LightOrange}{Orange!15}
\colorlet{LightGreen}{Green!15}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\bN}{\bb{N}}

\newcommand{\lo}{\mathrm{lo}}

\declaretheoremstyle[name=Theorem,]{thmsty}
\declaretheorem[style=thmsty,numberwithin=section]{theorem}
\tcolorboxenvironment{theorem}{colback=LightGray}

\declaretheoremstyle[name=Proposition,]{prosty}
\declaretheorem[style=prosty,numberlike=theorem]{proposition}
\tcolorboxenvironment{proposition}{colback=LightOrange}

\declaretheoremstyle[name=Principle,]{prcpsty}
\declaretheorem[style=prcpsty,numberlike=theorem]{principle}
\tcolorboxenvironment{principle}{colback=LightGreen}

\setstretch{1.2}
\geometry{
    textheight=9in,
    textwidth=5.5in,
    top=1in,
    headheight=12pt,
    headsep=25pt,
    footskip=30pt
}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		notes on \LARGE \textbf{\uppercase{The Little Typer}
		\HRule{2.0pt} \\ [0.6cm] \LARGE{CSC392} \vspace*{10\baselineskip}}
		}
\date{}
\author{\textbf{Mustafa Motiwala} \\ 
		1009298868}

\maketitle
\newpage

\tableofcontents
\newpage

% ------------------------------------------------------------------------------

\section{The More Things Change, the More They Stay the Same}
\subsection{Summary}
This chapter introduces terminology, focusing on \textit{judgements} (propositional statements of a specific shape), \textit{expressions} (every well-formed statement about which it makes sense to make judgements), and \textit{types}.

\subsection{The \ttt{Atom} type}
\begin{itemize}
    \item infinitely many constructors! (each atom constructs itself)
    \item an atom is a tick-mark followed by a sequence of letters and hyphens
    \begin{itemize}
        \item \ttt{'a, 'b, 'a-b-c} are atoms
        \item \ttt{'0, 'a0, ', ''} are \textbf{not} atoms
    \end{itemize}
\end{itemize}

\subsection{Judgements}
\begin{itemize}
    \item Has \textbf{four} forms
        \begin{enumerate}
            \item \underline{\phantom{blank}} is a \underline{\phantom{blank}}.
                \begin{itemize}
                    \item \ttt{'a} is a \ttt{Atom}.
                    \item \ttt{'0} is a \ttt{Atom} (not true but still a judgement).
                \end{itemize}
            \item \underline{\phantom{blank}} is the same \underline{\phantom{blank}} as \underline{\phantom{blank}}.
                \begin{itemize}
                    \item \ttt{'a} is the same \ttt{Atom} as \ttt{'a}.
                    \item \ttt{'b} is the same \ttt{Atom} as \ttt{(cdr (cons 'a 'b))}.
                \end{itemize}
            \item \underline{\phantom{blank}} is a type.
                \begin{itemize}
                    \item \ttt{Atom} is a type.
                    \item \ttt{(Pair Atom Atom)} is a type.
                \end{itemize}
            \item \underline{\phantom{blank}} and \underline{\phantom{blank}} are the same type.
                \begin{itemize}
                    \item \ttt{Atom} and \ttt{Atom} are the same type.
                \end{itemize}
        \end{enumerate}
    \item Can be believable (true) or not believable (false).
    \item Some judgements require other judgements (i.e, presuppositions) to even make sense.
        \begin{itemize}
            \item the judgment ``\ttt{'a} is the same \ttt{'b} as \ttt{'c}" requires first the judgement that ``\ttt{'b} is a type"
        \end{itemize}
\end{itemize}

\subsection{Normal Forms}
\begin{itemize}
    \item The \textit{normal form} of an expression is ``the most direct" (\textcolor{red}{how can we formalize this?}) way of writing that expression.
    \item Allows us to define equality on expressions. Two expressions are the same if and only if their normal forms are the same.
        \begin{itemize}
            \item \textbf{Note:} Sameness is a judgement that is different for types and non-types.
            \item If expressions \(A\) and \(B\) are types, then they are the same type (judgement 4) iff their normal forms are identical.
            \item If expressions \(A\) and \(B\) are not types but are themselves described by a type \(T\) (judgement 1), then \(A\) and \(B\) are the same iff their normal forms (with respect to \(T\)) are identical.
        \end{itemize}
\end{itemize}

\subsection{Constructors \& Type Constructors}
\begin{itemize}
    \item A type is defined by describing its constructors; \textbf{constructor expressions are the direct ways of building expressions with that type}
        \begin{itemize}
            \item \ttt{zero} and \ttt{add1} are the constructors of the \ttt{Nat} type.
            \item \ttt{cons} is the constructor of \ttt{Pair} types.
            \item Each atom constructs itself.
        \end{itemize}
    \item type constructors construct types.
        \begin{itemize}
            \item \ttt{Pair} is a type constructor; \ttt{Pair} on its own is not a type - it needs two arguments to define a new type.
        \end{itemize}
\end{itemize}

\subsection{Values}
\begin{itemize}
    \item A value is an expression with a constructor at the top.
    \item Since constructor arguments do not have to be normal, not all values are normal.
    \item Finding a value of an expression is known as evaluation.
    \item Since values don't have to be normal, one expression can have multiple values.
    \item (\textbf{not in book}) normal forms (of non-type expressions) are values.
\end{itemize}

\subsection{Claims and Definitions}
\begin{itemize}
    \item We associate a name with an expression via \ttt{define}
    \begin{itemize}
        \item \ttt{(define two (add1 (add1 zero)))}
    \end{itemize}
    \item Names must first be given types via \ttt{claim} \textit{before defining}.
    \begin{itemize}
        \item \ttt{(claim two Nat)}
    \end{itemize}
    \item These are forever. Names can be \ttt{claim}ed and \ttt{define}d at most once.
\end{itemize}

\section{Doin' What Comes Naturally}
\subsection{Summary}
This chapter focuses heavily on \textit{eliminators} which are opposed to \textit{constructors} that are discussed in the previous chapter.
\\ \\
We discuss the \(\lambda\) constructor and its eliminator, the application operator (juxtaposition in Pie). The \ttt{which-Nat} eliminator for the \ttt{Nat} type is also introduced.
\\ \\
Recursion is not an option in Pie.
\\ \\
We also discuss the \(\mathcal{U}\) type, which is the type of types. Every \(\mathcal{U}\) is a type, but not every type is a \(\mathcal{U}\); this is because \(\mathcal{U}\) is a type but is not a \(\mathcal{U}\) (no type is itself).
\\ \\
Other trivial things like the semantics of function application (substitution), ``neutral" expressions (expressions with free variables), and more on pairs, \ttt{cons}, \ttt{car}, and \ttt{cdr}.
\subsection{Constructors and Eliminators}
\begin{itemize}
    \item Constructors \textit{build} values whereas Eliminators \textit{dismantle} values.
        \begin{itemize}
            \item \ttt{(cons 1 2)} builds a \ttt{(Pair Nat Nat)}; to then access the numbers \ttt{1} and \ttt{2} again, we use \ttt{car} and \ttt{cdr}.
            \item \ttt{(\(\lambda\) (s) s)} builds a \ttt{(\(\rightarrow\) Atom Atom)}; application is the eliminator for functions
        \end{itemize}
    \item The application eliminator for functions works by pure substitution. Hence, if \ttt{f} is a \ttt{(\(\rightarrow\) X Y)} then \ttt{(\(\lambda\) (y) (f y))} is the same \ttt{(\(\rightarrow\) X Y)} as \ttt{f} \textit{as long as \ttt{y} does not appear in \ttt{f}}. \textcolor{red}{Is this last condition really necessary in Pie, or have the authors introduced it just to make teaching the semantics of function application simpler?}
    \item The eliminator for \ttt{Nat} is \ttt{which-Nat} which takes a \ttt{Nat} \(k\), an expression which is returned if \(k = 0\) and a function \ttt{f} which, if \(k = \ttt{(add1 n)}\) is equal to \ttt{(f n)}. So, \[
        \ttt{(\(\lambda\) (k) (which-Nat k zero add1))}
    \]
    is a silly way of implementing the identity on \ttt{Nat}. \textcolor{red}{How do we write the type of \ttt{which-Nat}? What is the syntax for type variables?}
    \item \textbf{Note:} in languages like Haskell and Erlang that support pattern matching, it seems like we get eliminators built in to the syntax of the language. \textcolor{red}{How do Pie eliminators differ from pattern matching?}
\end{itemize}
\subsection{Type Values and the Universal Type \(\mathcal{U}\)}
\begin{itemize}
    \item \ttt{\(\mathcal{U}\)} is the universal type; it is the type of types.
    \item To define a type alias, we use \ttt{(claim alias \(\mathcal{U}\))} and \ttt{(define alias type-expr)}
        \begin{itemize}
            \item \ttt{(claim Predicate \(\mathcal{U}\))} and \ttt{(define Predicate (\(\rightarrow\) Nat Bool)}
        \end{itemize}
    \item Type constructors are parameterized types, such as \ttt{Pair} or \ttt{\(\rightarrow\)}.
    \item Type values are expressions with a type constructor at the top.
    \item Every \(\mathcal{U}\) is a type; but not all types are \(\mathcal{U}\) (in particular, \(\mathcal{U}\) is a type but not a \(\mathcal{U}\) because no type is itself)
\end{itemize}
\subsection{Equivalence of expressions}
\begin{itemize}
    \item Neutral expressions are those with free variables; identically written neutral expressions are always the same, regardless of type.
    \item The semantics of \ttt{claim} and \ttt{define} are as you'd expect; if \ttt{name} is \ttt{claim}ed to be an \ttt{X} and \ttt{define}d to be \ttt{expr}, then \ttt{name} is the same \ttt{X} as \ttt{expr}.
    \item \(\eta\)-equivalence; \ttt{f} is the same function as \ttt{(\(\lambda\) (x) (f x))}.
    \item If \ttt{p} is a \ttt{(Pair X Y)} then \ttt{p} is the same \ttt{(Pair X Y)} as \ttt{(cons (car p) (cdr p))}.
\end{itemize}
\section{Eliminate All Natural Numbers!}
\subsection{Summary}
This chapter is all about two new eliminators for \ttt{Nat}, \ttt{iter-Nat} and \ttt{rec-Nat}.
\\ \\
These solve the main problem with \ttt{which-Nat}, which is that it only eliminates one constructor at a time. That is, if \ttt{n = (add1 k)}, then \ttt{which-Nat} will eliminate the singular \ttt{add1} but will not eliminate \ttt{k}. In contrast, \ttt{iter-Nat} and \ttt{rec-Nat} will eliminate all the way down to \ttt{zero}.
\\ \\
\ttt{iter-Nat} takes a natural number \(n\), an initial value \(s\) of type \(X\), and a unary function \(f : X \to X\), and returns \(f^n(s)\) where \(f^n\) is the \(n\)-fold composition.
\\ \\
\ttt{rec-Nat} takes a natural number \(n\), an initial value \(s\), and a binary function \(f : \mathbb{N} \times X \to X\) and returns \[
    f(n - 1, f(n-2, f(\dots, f(0, s)\dots)))
\]
The chapter ends with a note on currying: all functions in Pie are functions of one variable and those functions which look multivariable are in fact just single variable functions whose return type is a new function.
\subsection{Totality} 
A function is \textit{total} if it assigns a value to every possible argument. Totality is built into the ``typical" notion of functions from mathematics, as a function \(f : A \to B\) is not a function if \(f(a)\) is not defined for some element \(a \in A\). In Pie, \textit{all functions are total.}
\subsection{The \ttt{iter-Nat} eliminator}
For \ttt{X} a type, \ttt{target} a \ttt{Nat}, \ttt{base} a \ttt{X}, and \ttt{step} a function from \ttt{X} to \ttt{X}, \[ E \coloneqq \ttt{(iter-Nat target base step)} \] is an \ttt{X}. If \ttt{target} is zero, then \(E\) is the same \ttt{X} as \ttt{base}. Otherwise, if \(E = \) \ttt{(add1 n)}, then \(E\) is the same \ttt{X} as \[
    \ttt{(step (iter-Nat n base step))}
\]
Intuitively, \ttt{iter-Nat} iterates the function \ttt{step} \ttt{target} times on \ttt{base}.
\subsection{The \ttt{rec-Nat} eliminator} \label{rec-nat-elim}
For \ttt{X} a type, \ttt{target} a \ttt{Nat}, \ttt{base} a \ttt{X}, and \ttt{step} a binary function of \ttt{Nat} and \ttt{X} to \ttt{X}, \[ E \coloneqq \ttt{(rec-Nat target base step)} \] is an \ttt{X}. If \ttt{target} is zero, then \(E\) is the same \ttt{X} as \ttt{base}. Otherwise, if \(E = \) \ttt{(add1 n)}, then \(E\) is the same \ttt{X} as \[
    \ttt{(step n (rec-Nat n base step))}
\]
\ttt{rec-Nat} achieves \href{https://en.wikipedia.org/wiki/Primitive_recursive_function}{primitive recursion} on the naturals. I don't really know what this means yet, but it looks cool!
\subsection{Superfluence of \ttt{which-Nat} and \ttt{iter-Nat} with respect to \ttt{rec-Nat}}
\ttt{rec-Nat} can be used to implement \ttt{which-Nat} and \ttt{iter-Nat} by using a function which ignores the second and first arguments respectively. That is, \[
    \ttt{(which-Nat n s f)} = \ttt{(rec-Nat n s (\(\lambda\) (n-1 \_) (f n-1)))}
\]
and \[
    \ttt{(iter-Nat n s f)} = \ttt{(rec-Nat n s (\(\lambda\) (\_ f-n-1) (f f-n-1)))}
\]
\subsection{Some notes on primitive recursion}
As mentioned in \autoref{rec-nat-elim}, the \ttt{rec-Nat} eliminator achieves primitive recursion.
\begin{itemize}
    \item 
        Primitive recursion \textbf{does not} yield every possible computable function. A cool counterexample is the \href{https://en.wikipedia.org/wiki/Ackermann_function}{Ackermann function} which is well-defined, total, and computable, but not primitive recursive. \textcolor{red}{Does this mean that the Ackermann function can not be defined in Pie? Does Pie have more constructs beyond \ttt{rec-Nat} capable of surpassing the computing power of primitive recursion?}
    \item
        An intuitive way of understanding the computing power of primitive recursion is via ``the computer language" definition. That is, primitive recursion has the same computing power as a programming language with arithmetic, conditionals, comparisons, and \textbf{bounded} loops.
    \item
        Clearly, \ttt{rec-Nat} allows us to define functions that depend only on their previous value. That is, if \(f : \mathbb{N} \to \mathbb{N}\) is a function such that \(f(n + 1)\) is defined in terms of \(f(n)\) only, then it is easy to implement this using \ttt{rec-Nat} (\textcolor{red}{Is this a sufficient condition for primitive recursion? Do there exist functions like this that are not primitive recursive?}) What if \(f\) depends on two or more previous values, such as the Fibonacci function? We can use something called \href{https://en.wikipedia.org/wiki/Course-of-values_recursion}{course of values recursion} to define these.
    \item
        As a concrete example of the above, here is how we might encode the function \(F : \bN \to \bN\) defined by \[
            F(n) = \begin{cases}
                        1 & n < 2 \\
                        F(n - 1) + F(n - 2) & n \geq 2
                   \end{cases}
        \]
        into a function \(g : \bN \to \bN\) so that \(g(n + 1)\) depends only on \(g(n)\). 
        \\ \\
        We define \(g(n) = 2^{F(n)}3^{F(n + 1)}\). Then, \(g(0) = 6\) and \begin{align*}
            g(n + 1) &= 2^{F(n + 1)}3^{F(n + 2)} \\
                     &= 2^{\lo(3, g(n))}3^{F(n + 1) + F(n)} \\
                     &= 2^{\lo(3, g(n))}3^{F(n + 1)} 3^{F(n)} \\
                     &= 2^{\lo(3, g(n))}3^{\lo(3, g(n))} 3^{\lo(2, g(n))}
        \end{align*}
        Here, the \(\lo(a, b)\) function gives the number of times \(b\) is divisible by \(a\). \hyperref[code:lo]{This function}, as well as \hyperref[code:exponentiation]{exponentiation} and \hyperref[code:multiplication]{multiplication} can be defined using primitive recursion, and so \(g\) can be defined using primitive recursion, and so \(F(n) = \lo(2, g(n))\) can be \hyperref[code:Fibonacci]{defined via primitive recursion}, and hence the Fibonacci function is primitive recursive!  
\end{itemize}
\section{Easy as Pie}
\subsection{Summary}
This chapter is all about the \(\Pi\) type constructor, which allows us to abstract functions over types. With the \(\Pi\) type constructor, we can define functions whose return type depends on the types of its arguments. 
\subsection{The \(\Pi\) Constructor}
The \(\Pi\) constructor has the form \[
    \ttt{(\(\Pi\) ((x\(_1\) X\(_1\)) ... (x\(_n\) X\(_n\))) R)}
\]
where each \(\ttt{x}_i\) is an identifier, \(\ttt{X}_i\) is a type, and \ttt{R} is an expression describing a type, possible using the identifiers \(\ttt{x}_i\) (where \(\ttt{x}_i\) represents a value of type \(\ttt{X}_i\)).
\\ \\
A value of type \ttt{(\(\Pi\) ((x\(_1\) X\(_1\)) ... (x\(_n\) X\(_n\))) R)} is a function which takes \(n\) arguments, where the \(i\)'th argument is of type \(\ttt{X}_i\) and produces a result of type \ttt{R}.
\subsection{Superfluence of \(\to\) with respect to \(\Pi\)}
The \(\to\) type constructor is syntax sugar for the \(\Pi\) type constructor. The type \[
    \ttt{(\(\to\) X\(_1\) ... X\(_n\) R)}
\] is equivalent to the type \[
    \ttt{(\(\Pi\) ((x\(_1\) X\(_1\)) ... (x\(_n\) X\(_n\))) R)}
\]
The power of the \(\Pi\) operator comes from the fact that the \ttt{R} type is allowed to depend on the \ttt{x}\(_i\)'s, so if \ttt{X}\(_i\) is \(\mathcal{U}\), then \ttt{R} can denote a variable type.
\section{Lists, Lists, and More Lists}
\subsection{Summary}
This chapter introduces the \ttt{List} type, which behaves about how you'd expect. There isn't really anything new or surprising here.
\subsection{The \ttt{List} type}
Given a type \ttt{E}, \ttt{(List E)} describes a new type.
\subsection{The \ttt{nil} and \ttt{::} constructors}
The \ttt{List} type has two constructors, \ttt{nil} and \ttt{::}; the first constructs the empty list whereas the second tacks on a new element ``to the front" of an existing list.
\subsection{The \ttt{rec-List} eliminator}
Given a list \((x_1, \dots, x_n)\) of type \ttt{(List A)}, some value \(s\) of type \(X\), and a function \(f : \ttt{A} \times \ttt{(List A)} \times X \to X\), the \ttt{rec-List} eliminator returns \[
    f(x_1, (x_2, \dots, x_n), f(x_2, (x_3, \dots, x_n), f(\dots, f(x_n, (), s) \dots)))
\]
In other words, let \ttt{target} be a \ttt{(List E)}, \ttt{base} be an \ttt{X}, and \ttt{step} be a \ttt{(\(\to\) E (List E) X X)}. If \ttt{target} is the same as \ttt{nil}, then \ttt{(rec-List target base step)} is the same \ttt{X} as \ttt{base}. If \ttt{target} is \ttt{(:: e es)}, then \ttt{(rec-List target base step)} is the same \ttt{X} as \[
    \ttt{(step e es (rec-List es base step))}
\]
\ttt{rec-List} is primitive recursion on lists. 
\section{Precisely How Many?}
\subsection{Summary}
This chapter gives us our first taste of dependent types. The \ttt{Vec} type describes lists with length, so that it depends not only on a type, but on a \textit{value} as well.
\\ \\
We see two eliminators for the \ttt{Vec} type, \ttt{head} and \ttt{tail}, and discuss how to write down the types of these eliminators so that they are total.
\subsection{The \ttt{Vec} type}
Given a type \ttt{E}, and a \ttt{Nat k}, \ttt{(Vec E k)} is a type which describes a list of elements of type \ttt{E} with length \ttt{k}.
\subsection{The \ttt{vecnil} and \ttt{vec::} constructors}
The \ttt{vecnil} constructor constructs a \ttt{(Vec E 0)}.
\\ \\
The \ttt{vec::} constructor takes a value of type \ttt{E} and a \ttt{(Vec E k)} and constructs a \ttt{(Vec e (add1 k))}.
\subsection{The \ttt{head} and \ttt{tail} eliminators}
The \ttt{head} and \ttt{tail} eliminators do what they sound like they do; \ttt{head} returns the first element whereas \ttt{tail} drops the first element and returns the rest. These are natural functions to define on lists, but they can not be defined for any \ttt{List} type, because the expressions \ttt{(head nil)} and \ttt{(tail nil)} are meaningless. 
\\ \\
Clearly, \ttt{head} and \ttt{tail} are only meaningful when applied to non-empty lists; so we somehow need to describe a type that excludes empty lists! This is where \(\Pi\) comes in; \[
    \text{\ttt{head} has type \ttt{(\(\Pi\) ((a U) (k Nat)) (\(\to\) (Vec a (add1 k)) a))}}
\] and \[
    \text{\ttt{tail} has type \ttt{(\(\Pi\) ((a U) (k Nat)) (\(\to\) (Vec a (add1 k)) (Vec a k)))}}
\]
The type of \ttt{head} depends on a natural number \(k\); given a \(k\), \ttt{head} accepts a vector of length \(k + 1\), thereby guaranteeing the existence of at least one element in the vector and thus making \ttt{head} total. Similarly for \ttt{tail}.
\subsection{Some initial impressions}
Dependent types give us \textit{a lot} more power to describe programs. Suddenly, we can Pie a lot more ``dynamic". For example, consider the following Python program:
\begin{minted}{python}
    apply = lambda f, args: f(*args)
\end{minted}
It is clear what \ttt{apply} is \textit{supposed} to do: take a function and some collection of arguments, and apply the function to those arguments. It is also clear that this function can easily raise an error, but that's par for the course in Python. However, in Pie, we can actually give a reasonable type for \ttt{apply}: \[
    \ttt{(\(\Pi\) ((a U) (k Nat)) (\(\to\) (NaryOp k a) (Vec a k) a))}
\] where \ttt{NaryOp} is as \hyperref[code:NaryOp]{defined here}. 
\\ \\
Of course, the above type doesn't fully describe the type of our Python program \ttt{apply}, but it's pretty good!
\\ \\
Another cool (but rather silly) use case is defining \ttt{length}, which we can simply define as:
\begin{minted}{scheme}
(claim length (Pi ((a U) (k Nat)) (-> (Vec a k) Nat)))
(define length (lambda (a k v) k))
\end{minted}
Similarly, we can define more expressive types for familiar list functions such as \hyperref[code:map]{\ttt{map}} and \hyperref[code:reverse]{\ttt{reverse}} which would express the fact that these do not affect the length of the input list, or \ttt{repeat}, whose type would reflect the fact that the length of the output list is the same as the input natural number.
\\ \\
Unfortunately, we can't implement a lot of these quite yet, since they require more power than just \ttt{head} or \ttt{tail}. 
\appendix
\section{Some Cool Pie Code} \label{pie-code-appendix}
\input{code-listing}
\end{document}
