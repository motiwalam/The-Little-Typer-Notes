\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts, mathtools}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage[margin=0.7in]{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
\usepackage{minted}
\usepackage{etoc}
\usepackage{etoolbox}
\AtBeginEnvironment{appendix}{\etocsettocdepth.toc{section}\etocignoretoctocdepth}

\hypersetup{
    colorlinks,
    linkcolor={blue!80!black},
    citecolor={blue!80!black},
    urlcolor={blue!80!black}
}

\colorlet{LightGray}{White!90!Periwinkle}
\colorlet{LightOrange}{Orange!15}
\colorlet{LightGreen}{Green!15}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\bN}{\bb{N}}

\newcommand{\lo}{\mathrm{lo}}

\declaretheoremstyle[name=Theorem,]{thmsty}
\declaretheorem[style=thmsty,numberwithin=section]{theorem}
\tcolorboxenvironment{theorem}{colback=LightGray}

\declaretheoremstyle[name=Proposition,]{prosty}
\declaretheorem[style=prosty,numberlike=theorem]{proposition}
\tcolorboxenvironment{proposition}{colback=LightOrange}

\declaretheoremstyle[name=Principle,]{prcpsty}
\declaretheorem[style=prcpsty,numberlike=theorem]{principle}
\tcolorboxenvironment{principle}{colback=LightGreen}

\setstretch{1.2}
\geometry{
    textheight=9in,
    textwidth=5.5in,
    top=1in,
    headheight=12pt,
    headsep=25pt,
    footskip=30pt
}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		notes on \LARGE \textbf{\uppercase{The Little Typer}
		\HRule{2.0pt} \\ [0.6cm] \LARGE{CSC392} \vspace*{10\baselineskip}}
		}
\date{}
\author{\textbf{Mustafa Motiwala} \\ 
		1009298868}

\maketitle
\newpage

\tableofcontents
\newpage

% ------------------------------------------------------------------------------

\section{The More Things Change, the More They Stay the Same}
\subsection{Summary}
This chapter introduces terminology, focusing on \textit{judgements} (propositional statements of a specific shape), \textit{expressions} (every well-formed statement about which it makes sense to make judgements), and \textit{types}.

\subsection{The \ttt{Atom} type}
\begin{itemize}
    \item infinitely many constructors! (each atom constructs itself)
    \item an atom is a tick-mark followed by a sequence of letters and hyphens
    \begin{itemize}
        \item \ttt{'a, 'b, 'a-b-c} are atoms
        \item \ttt{'0, 'a0, ', ''} are \textbf{not} atoms
    \end{itemize}
\end{itemize}

\subsection{Judgements}
\begin{itemize}
    \item Has \textbf{four} forms
        \begin{enumerate}
            \item \underline{\phantom{blank}} is a \underline{\phantom{blank}}.
                \begin{itemize}
                    \item \ttt{'a} is a \ttt{Atom}.
                    \item \ttt{'0} is a \ttt{Atom} (not true but still a judgement).
                \end{itemize}
            \item \underline{\phantom{blank}} is the same \underline{\phantom{blank}} as \underline{\phantom{blank}}.
                \begin{itemize}
                    \item \ttt{'a} is the same \ttt{Atom} as \ttt{'a}.
                    \item \ttt{'b} is the same \ttt{Atom} as \ttt{(cdr (cons 'a 'b))}.
                \end{itemize}
            \item \underline{\phantom{blank}} is a type.
                \begin{itemize}
                    \item \ttt{Atom} is a type.
                    \item \ttt{(Pair Atom Atom)} is a type.
                \end{itemize}
            \item \underline{\phantom{blank}} and \underline{\phantom{blank}} are the same type.
                \begin{itemize}
                    \item \ttt{Atom} and \ttt{Atom} are the same type.
                \end{itemize}
        \end{enumerate}
    \item Can be believable (true) or not believable (false).
    \item Some judgements require other judgements (i.e, presuppositions) to even make sense.
        \begin{itemize}
            \item the judgment ``\ttt{'a} is the same \ttt{'b} as \ttt{'c}" requires first the judgement that ``\ttt{'b} is a type"
        \end{itemize}
\end{itemize}

\subsection{Normal Forms}
\begin{itemize}
    \item The \textit{normal form} of an expression is ``the most direct" (\textcolor{red}{how can we formalize this?}) way of writing that expression.
    \item Allows us to define equality on expressions. Two expressions are the same if and only if their normal forms are the same.
        \begin{itemize}
            \item \textbf{Note:} Sameness is a judgement that is different for types and non-types.
            \item If expressions \(A\) and \(B\) are types, then they are the same type (judgement 4) iff their normal forms are identical.
            \item If expressions \(A\) and \(B\) are not types but are themselves described by a type \(T\) (judgement 1), then \(A\) and \(B\) are the same iff their normal forms (with respect to \(T\)) are identical.
        \end{itemize}
\end{itemize}

\subsection{Constructors \& Type Constructors}
\begin{itemize}
    \item A type is defined by describing its constructors; \textbf{constructor expressions are the direct ways of building expressions with that type}
        \begin{itemize}
            \item \ttt{zero} and \ttt{add1} are the constructors of the \ttt{Nat} type.
            \item \ttt{cons} is the constructor of \ttt{Pair} types.
            \item Each atom constructs itself.
        \end{itemize}
    \item type constructors construct types.
        \begin{itemize}
            \item \ttt{Pair} is a type constructor; \ttt{Pair} on its own is not a type - it needs two arguments to define a new type.
        \end{itemize}
\end{itemize}

\subsection{Values}
\begin{itemize}
    \item A value is an expression with a constructor at the top.
    \item Since constructor arguments do not have to be normal, not all values are normal.
    \item Finding a value of an expression is known as evaluation.
    \item Since values don't have to be normal, one expression can have multiple values.
    \item (\textbf{not in book}) normal forms (of non-type expressions) are values.
\end{itemize}

\subsection{Claims and Definitions}
\begin{itemize}
    \item We associate a name with an expression via \ttt{define}
    \begin{itemize}
        \item \ttt{(define two (add1 (add1 zero)))}
    \end{itemize}
    \item Names must first be given types via \ttt{claim} \textit{before defining}.
    \begin{itemize}
        \item \ttt{(claim two Nat)}
    \end{itemize}
    \item These are forever. Names can be \ttt{claim}ed and \ttt{define}d at most once.
\end{itemize}

\section{Doin' What Comes Naturally}
\subsection{Summary}
This chapter focuses heavily on \textit{eliminators} which are opposed to \textit{constructors} that are discussed in the previous chapter.
\\ \\
We discuss the \(\lambda\) constructor and its eliminator, the application operator (juxtaposition in Pie). The \ttt{which-Nat} eliminator for the \ttt{Nat} type is also introduced.
\\ \\
Recursion is not an option in Pie.
\\ \\
We also discuss the \(\mathcal{U}\) type, which is the type of types. Every \(\mathcal{U}\) is a type, but not every type is a \(\mathcal{U}\); this is because \(\mathcal{U}\) is a type but is not a \(\mathcal{U}\) (no type is itself).
\\ \\
Other trivial things like the semantics of function application (substitution), ``neutral" expressions (expressions with free variables), and more on pairs, \ttt{cons}, \ttt{car}, and \ttt{cdr}.
\subsection{Constructors and Eliminators}
\begin{itemize}
    \item Constructors \textit{build} values whereas Eliminators \textit{dismantle} values.
        \begin{itemize}
            \item \ttt{(cons 1 2)} builds a \ttt{(Pair Nat Nat)}; to then access the numbers \ttt{1} and \ttt{2} again, we use \ttt{car} and \ttt{cdr}.
            \item \ttt{(\(\lambda\) (s) s)} builds a \ttt{(\(\rightarrow\) Atom Atom)}; application is the eliminator for functions
        \end{itemize}
    \item The application eliminator for functions works by pure substitution. Hence, if \ttt{f} is a \ttt{(\(\rightarrow\) X Y)} then \ttt{(\(\lambda\) (y) (f y))} is the same \ttt{(\(\rightarrow\) X Y)} as \ttt{f} \textit{as long as \ttt{y} does not appear in \ttt{f}}. \textcolor{red}{Is this last condition really necessary in Pie, or have the authors introduced it just to make teaching the semantics of function application simpler?}
    \item The eliminator for \ttt{Nat} is \ttt{which-Nat} which takes a \ttt{Nat} \(k\), an expression which is returned if \(k = 0\) and a function \ttt{f} which, if \(k = \ttt{(add1 n)}\) is equal to \ttt{(f n)}. So, \[
        \ttt{(\(\lambda\) (k) (which-Nat k zero add1))}
    \]
    is a silly way of implementing the identity on \ttt{Nat}. \textcolor{red}{How do we write the type of \ttt{which-Nat}? What is the syntax for type variables?}
    \item \textbf{Note:} in languages like Haskell and Erlang that support pattern matching, it seems like we get eliminators built in to the syntax of the language. \textcolor{red}{How do Pie eliminators differ from pattern matching?}
\end{itemize}
\subsection{Type Values and the Universal Type \(\mathcal{U}\)}
\begin{itemize}
    \item \ttt{\(\mathcal{U}\)} is the universal type; it is the type of types.
    \item To define a type alias, we use \ttt{(claim alias \(\mathcal{U}\))} and \ttt{(define alias type-expr)}
        \begin{itemize}
            \item \ttt{(claim Predicate \(\mathcal{U}\))} and \ttt{(define Predicate (\(\rightarrow\) Nat Bool)}
        \end{itemize}
    \item Type constructors are parameterized types, such as \ttt{Pair} or \ttt{\(\rightarrow\)}.
    \item Type values are expressions with a type constructor at the top.
    \item Every \(\mathcal{U}\) is a type; but not all types are \(\mathcal{U}\) (in particular, \(\mathcal{U}\) is a type but not a \(\mathcal{U}\) because no type is itself)
\end{itemize}
\subsection{Equivalence of expressions}
\begin{itemize}
    \item Neutral expressions are those with free variables; identically written neutral expressions are always the same, regardless of type.
    \item The semantics of \ttt{claim} and \ttt{define} are as you'd expect; if \ttt{name} is \ttt{claim}ed to be an \ttt{X} and \ttt{define}d to be \ttt{expr}, then \ttt{name} is the same \ttt{X} as \ttt{expr}.
    \item \(\eta\)-equivalence; \ttt{f} is the same function as \ttt{(\(\lambda\) (x) (f x))}.
    \item If \ttt{p} is a \ttt{(Pair X Y)} then \ttt{p} is the same \ttt{(Pair X Y)} as \ttt{(cons (car p) (cdr p))}.
\end{itemize}
\section{Eliminate All Natural Numbers!}
\subsection{Summary}
This chapter is all about two new eliminators for \ttt{Nat}, \ttt{iter-Nat} and \ttt{rec-Nat}.
\\ \\
These solve the main problem with \ttt{which-Nat}, which is that it only eliminates one constructor at a time. That is, if \ttt{n = (add1 k)}, then \ttt{which-Nat} will eliminate the singular \ttt{add1} but will not eliminate \ttt{k}. In contrast, \ttt{iter-Nat} and \ttt{rec-Nat} will eliminate all the way down to \ttt{zero}.
\\ \\
\ttt{iter-Nat} takes a natural number \(n\), an initial value \(s\) of type \(X\), and a unary function \(f : X \to X\), and returns \(f^n(s)\) where \(f^n\) is the \(n\)-fold composition.
\\ \\
\ttt{rec-Nat} takes a natural number \(n\), an initial value \(s\), and a binary function \(f : \mathbb{N} \times X \to X\) and returns \[
    f(n - 1, f(n-2, f(\dots, f(0, s)\dots)))
\]
The chapter ends with a note on currying: all functions in Pie are functions of one variable and those functions which look multivariable are in fact just single variable functions whose return type is a new function.
\subsection{Totality} 
A function is \textit{total} if it assigns a value to every possible argument. Totality is built into the ``typical" notion of functions from mathematics, as a function \(f : A \to B\) is not a function if \(f(a)\) is not defined for some element \(a \in A\). In Pie, \textit{all functions are total.}
\subsection{The \ttt{iter-Nat} eliminator}
For \ttt{X} a type, \ttt{target} a \ttt{Nat}, \ttt{base} a \ttt{X}, and \ttt{step} a function from \ttt{X} to \ttt{X}, \[ E \coloneqq \ttt{(iter-Nat target base step)} \] is an \ttt{X}. If \ttt{target} is zero, then \(E\) is the same \ttt{X} as \ttt{base}. Otherwise, if \(E = \) \ttt{(add1 n)}, then \(E\) is the same \ttt{X} as \[
    \ttt{(step (iter-Nat n base step))}
\]
Intuitively, \ttt{iter-Nat} iterates the function \ttt{step} \ttt{target} times on \ttt{base}.
\subsection{The \ttt{rec-Nat} eliminator} \label{rec-nat-elim}
For \ttt{X} a type, \ttt{target} a \ttt{Nat}, \ttt{base} a \ttt{X}, and \ttt{step} a binary function of \ttt{Nat} and \ttt{X} to \ttt{X}, \[ E \coloneqq \ttt{(rec-Nat target base step)} \] is an \ttt{X}. If \ttt{target} is zero, then \(E\) is the same \ttt{X} as \ttt{base}. Otherwise, if \(E = \) \ttt{(add1 n)}, then \(E\) is the same \ttt{X} as \[
    \ttt{(step n (rec-Nat n base step))}
\]
\ttt{rec-Nat} achieves \href{https://en.wikipedia.org/wiki/Primitive_recursive_function}{primitive recursion} on the naturals. I don't really know what this means yet, but it looks cool!
\subsection{Superfluence of \ttt{which-Nat} and \ttt{iter-Nat} with respect to \ttt{rec-Nat}}
\ttt{rec-Nat} can be used to implement \ttt{which-Nat} and \ttt{iter-Nat} by using a function which ignores the second and first arguments respectively. That is, \[
    \ttt{(which-Nat n s f)} = \ttt{(rec-Nat n s (\(\lambda\) (n-1 \_) (f n-1)))}
\]
and \[
    \ttt{(iter-Nat n s f)} = \ttt{(rec-Nat n s (\(\lambda\) (\_ f-n-1) (f f-n-1)))}
\]
\subsection{Superfluence of \ttt{rec-Nat} with respect to \ttt{iter-Nat}} \label{recNat-in-iterNat}
\ttt{iter-Nat} can be used to implement \ttt{rec-Nat}. Let \(X\) be a set, \(f : \mathbb{N} \times X \to X\) a function. Define \(g : \mathbb{N} \times X \to \mathbb{N} \times X\) by \[
    g(n, x) = (n + 1, f(n, x))
\]
Then, for all \(n \in \bN\), \(s \in X\), \(g^n(0, s) = (n, \ttt{rec-Nat}(n, s, f))\).
\\ \\
We can see this by induction on \(n\). Let \(s \in X\). In the base case, \[
    g^0(0, s) = (0, s) = (0, \ttt{rec-Nat}(0, s, f))
\]
Now, let \(k \in \bN\) be arbitrary and suppose \(g^k(0, s) = (k, \ttt{rec-Nat}(k, s, f))\). Then,
\begin{align*}
    g^{k + 1}(0, s) 
        &= g(g^k(0, s)) \\
        &= g(k, \ttt{rec-Nat}(k, s, f)) \\
        &= (k + 1, f(k, \ttt{rec-Nat}(k, s, f))) \\
        &= (k + 1, \ttt{rec-Nat}(k + 1, s, f))
\end{align*}
Of course, \(g^n(0, s)\) is given by \ttt{(iter-Nat n (cons 0 s) g)}, which gives the result.
\\ \\
This implementation of \ttt{rec-Nat} in terms of \ttt{iter-Nat} can be found \hyperref[code:rec-Nat2]{here}.
\subsection{Some notes on primitive recursion}
As mentioned in \autoref{rec-nat-elim}, the \ttt{rec-Nat} eliminator achieves primitive recursion.
\begin{itemize}
    \item 
        Primitive recursion \textbf{does not} yield every possible computable function. A cool counterexample is the \href{https://en.wikipedia.org/wiki/Ackermann_function}{Ackermann function} which is well-defined, total, and computable, but not primitive recursive. \textcolor{red}{Does this mean that the Ackermann function can not be defined in Pie? Does Pie have more constructs beyond \ttt{rec-Nat} capable of surpassing the computing power of primitive recursion?}
    \item
        An intuitive way of understanding the computing power of primitive recursion is via ``the computer language" definition. That is, primitive recursion has the same computing power as a programming language with arithmetic, conditionals, comparisons, and \textbf{bounded} loops.
    \item
        Clearly, \ttt{rec-Nat} allows us to define functions that depend only on their previous value. That is, if \(f : \mathbb{N} \to \mathbb{N}\) is a function such that \(f(n + 1)\) is defined in terms of \(f(n)\) only, then it is easy to implement this using \ttt{rec-Nat} (\textcolor{red}{Is this a sufficient condition for primitive recursion? Do there exist functions like this that are not primitive recursive?}) What if \(f\) depends on two or more previous values, such as the Fibonacci function? We can use something called \href{https://en.wikipedia.org/wiki/Course-of-values_recursion}{course of values recursion} to define these.
    \item
        As a concrete example of the above, here is how we might encode the function \(F : \bN \to \bN\) defined by \[
            F(n) = \begin{cases}
                        1 & n < 2 \\
                        F(n - 1) + F(n - 2) & n \geq 2
                   \end{cases}
        \]
        into a function \(g : \bN \to \bN\) so that \(g(n + 1)\) depends only on \(g(n)\). 
        \\ \\
        We define \(g(n) = 2^{F(n)}3^{F(n + 1)}\). Then, \(g(0) = 6\) and \begin{align*}
            g(n + 1) &= 2^{F(n + 1)}3^{F(n + 2)} \\
                     &= 2^{\lo(3, g(n))}3^{F(n + 1) + F(n)} \\
                     &= 2^{\lo(3, g(n))}3^{F(n + 1)} 3^{F(n)} \\
                     &= 2^{\lo(3, g(n))}3^{\lo(3, g(n))} 3^{\lo(2, g(n))}
        \end{align*}
        Here, the \(\lo(a, b)\) function gives the number of times \(b\) is divisible by \(a\). \hyperref[code:lo]{This function}, as well as \hyperref[code:exponentiation]{exponentiation} and \hyperref[code:multiplication]{multiplication} can be defined using primitive recursion, and so \(g\) can be defined using primitive recursion, and so \(F(n) = \lo(2, g(n))\) can be \hyperref[code:Fibonacci]{defined via primitive recursion}, and hence the Fibonacci function is primitive recursive!  
\end{itemize}
\section{Easy as Pie}
\subsection{Summary}
This chapter is all about the \(\Pi\) type constructor, which allows us to abstract functions over types. With the \(\Pi\) type constructor, we can define functions whose return type depends on the types of its arguments. 
\subsection{The \(\Pi\) Constructor}
The \(\Pi\) constructor has the form \[
    \ttt{(\(\Pi\) ((x\(_1\) X\(_1\)) ... (x\(_n\) X\(_n\))) R)}
\]
where each \(\ttt{x}_i\) is an identifier, \(\ttt{X}_i\) is a type, and \ttt{R} is an expression describing a type, possible using the identifiers \(\ttt{x}_i\) (where \(\ttt{x}_i\) represents a value of type \(\ttt{X}_i\)).
\\ \\
A value of type \ttt{(\(\Pi\) ((x\(_1\) X\(_1\)) ... (x\(_n\) X\(_n\))) R)} is a function which takes \(n\) arguments, where the \(i\)'th argument is of type \(\ttt{X}_i\) and produces a result of type \ttt{R}.
\subsection{Superfluence of \(\to\) with respect to \(\Pi\)}
The \(\to\) type constructor is syntax sugar for the \(\Pi\) type constructor. The type \[
    \ttt{(\(\to\) X\(_1\) ... X\(_n\) R)}
\] is equivalent to the type \[
    \ttt{(\(\Pi\) ((x\(_1\) X\(_1\)) ... (x\(_n\) X\(_n\))) R)}
\]
The power of the \(\Pi\) operator comes from the fact that the \ttt{R} type is allowed to depend on the \ttt{x}\(_i\)'s, so if \ttt{X}\(_i\) is \(\mathcal{U}\), then \ttt{R} can denote a variable type.
\section{Lists, Lists, and More Lists}
\subsection{Summary}
This chapter introduces the \ttt{List} type, which behaves about how you'd expect. There isn't really anything new or surprising here.
\subsection{The \ttt{List} type}
Given a type \ttt{E}, \ttt{(List E)} describes a new type.
\subsection{The \ttt{nil} and \ttt{::} constructors}
The \ttt{List} type has two constructors, \ttt{nil} and \ttt{::}; the first constructs the empty list whereas the second tacks on a new element ``to the front" of an existing list.
\subsection{The \ttt{rec-List} eliminator}
Given a list \((x_1, \dots, x_n)\) of type \ttt{(List A)}, some value \(s\) of type \(X\), and a function \(f : \ttt{A} \times \ttt{(List A)} \times X \to X\), the \ttt{rec-List} eliminator returns \[
    f(x_1, (x_2, \dots, x_n), f(x_2, (x_3, \dots, x_n), f(\dots, f(x_n, (), s) \dots)))
\]
In other words, let \ttt{target} be a \ttt{(List E)}, \ttt{base} be an \ttt{X}, and \ttt{step} be a \ttt{(\(\to\) E (List E) X X)}. If \ttt{target} is the same as \ttt{nil}, then \ttt{(rec-List target base step)} is the same \ttt{X} as \ttt{base}. If \ttt{target} is \ttt{(:: e es)}, then \ttt{(rec-List target base step)} is the same \ttt{X} as \[
    \ttt{(step e es (rec-List es base step))}
\]
\ttt{rec-List} is primitive recursion on lists.
\subsection{Some questions about \ttt{rec-List}}
\subsubsection{Implementing lists with \ttt{Nat}?}
Given functions \(\ttt{encode} : X \to \bN\) and \(\ttt{decode} : \bN \to X\), we can represent a \ttt{(List X)} \((x_0, \dots, x_n)\) as the natural number \[
    \prod_{i = 0}^n p_i^{\ttt{encode}(x_i)}
\] where \(p_i\) is the \(i\)'th prime number.
\\ \\
So, \textcolor{red}{might we implement the \ttt{List} type just using \ttt{Nat}? What might go wrong?}
\\ \\
Probably, a true equivalent to the \ttt{List} type is not possible, as writing the \ttt{encode} and \ttt{decode} functions for \ttt{Atom} is not possible. However, encoding and decoding functions are easy to write for \ttt{Nat} (successor \& predecessor) and types built on \ttt{Nat} (products of powers of primes \& \hyperref[code:lo]{\(p\)-adic valuations}), so we can at least consider lists of these types.
\\ \\
We can represent the empty list with \(0\) so that the length of a list \(\ell\) is 0 if \(\ell = 0\) and otherwise \(\min \{ n \in \bN : p_{n + 1} \nmid \ell \}\) which can be implemented using the \hyperref[code:mu]{bounded minimization operator} and the \hyperref[code:nth-prime]{nth-prime} function.
\\ \\
Then, \ttt{rec-List} should also be implementable by using \ttt{rec-Nat} with the target being the length of the list and the step function using \hyperref[code:nth-prime]{nth-prime} and \hyperref[code:lo]{lo} to extract the correct value of \ttt{e} and dividing by all the previous primes to get the value of \ttt{es}.
\subsubsection{The second argument in the step of \ttt{rec-List}}
The second argument of the \ttt{step} parameter of \ttt{rec-List} takes both the first element in the list and the remaining elements, as well as the ``almost result". \textcolor{red}{What is the purpose of this argument? Are there functions that can not be implemented without it?}
\\ \\
For one thing, the presence of this argument can be made sense of by an appeal to symmetry with \ttt{rec-Nat}. \ttt{Nat} and \ttt{List} are both very similar, in that they are both constructed by starting with a ``base" constructor of zero arguments and then repeatedly applying a sort of ``successor" constructor. \ttt{which-Nat} removes one instance of this successor constructor and gives you access to what's underneath, whereas \ttt{iter-Nat} eliminates ``all the way down" to the base constructor and gives you access to the partial results. \ttt{rec-Nat} combines the power of these two by giving the step function both what is immediately underneath the successor constructor and the partial result.
\\ \\
For \ttt{List}, the successor constructor takes two arguments, and so \ttt{rec-List} gives the step function both of these arguments, which are the head and the tail of the list.
\\ \\
This isn't exactly illuminating though. The question remains, \textcolor{red}{is this argument actually useful?} Now, I think the second argument is not \textit{strictly} necessary as long as you have the first one, since you can build it up from scratch, by using a similar trick as in \autoref{recNat-in-iterNat}. Again, though, what kind of algorithms \textit{require} this argument (whether it is explicitly passed in or built up from scratch)?
\section{Precisely How Many?}
\subsection{Summary}
This chapter gives us our first taste of dependent types. The \ttt{Vec} type describes lists with length, so that it depends not only on a type, but on a \textit{value} as well.
\\ \\
We see two eliminators for the \ttt{Vec} type, \ttt{head} and \ttt{tail}, and discuss how to write down the types of these eliminators so that they are total.
\subsection{The \ttt{Vec} type}
Given a type \ttt{E}, and a \ttt{Nat k}, \ttt{(Vec E k)} is a type which describes a list of elements of type \ttt{E} with length \ttt{k}.
\subsection{The \ttt{vecnil} and \ttt{vec::} constructors}
The \ttt{vecnil} constructor constructs a \ttt{(Vec E 0)}.
\\ \\
The \ttt{vec::} constructor takes a value of type \ttt{E} and a \ttt{(Vec E k)} and constructs a \ttt{(Vec e (add1 k))}.
\subsection{The \ttt{head} and \ttt{tail} eliminators}
The \ttt{head} and \ttt{tail} eliminators do what they sound like they do; \ttt{head} returns the first element whereas \ttt{tail} drops the first element and returns the rest. These are natural functions to define on lists, but they can not be defined for any \ttt{List} type, because the expressions \ttt{(head nil)} and \ttt{(tail nil)} are meaningless. 
\\ \\
Clearly, \ttt{head} and \ttt{tail} are only meaningful when applied to non-empty lists; so we somehow need to describe a type that excludes empty lists! This is where \(\Pi\) comes in; \[
    \text{\ttt{head} has type \ttt{(\(\Pi\) ((a U) (k Nat)) (\(\to\) (Vec a (add1 k)) a))}}
\] and \[
    \text{\ttt{tail} has type \ttt{(\(\Pi\) ((a U) (k Nat)) (\(\to\) (Vec a (add1 k)) (Vec a k)))}}
\]
The type of \ttt{head} depends on a natural number \(k\); given a \(k\), \ttt{head} accepts a vector of length \(k + 1\), thereby guaranteeing the existence of at least one element in the vector and thus making \ttt{head} total. Similarly for \ttt{tail}.
\subsection{Some initial impressions}
Dependent types give us \textit{a lot} more power to describe programs. Suddenly, we can make Pie a lot more ``dynamic". For example, consider the following Python program:
\begin{minted}{python}
    apply = lambda f, args: f(*args)
\end{minted}
It is clear what \ttt{apply} is \textit{supposed} to do: take a function and some collection of arguments, and apply the function to those arguments. It is also clear that this function can easily raise an error, but that's par for the course in Python. However, in Pie, we can actually give a reasonable type for \ttt{apply}: \[
    \ttt{(\(\Pi\) ((a U) (k Nat)) (\(\to\) (NaryOp k a) (Vec a k) a))}
\] where \ttt{NaryOp} is as \hyperref[code:NaryOp]{defined here}. 
\\ \\
Of course, the above type doesn't fully describe the type of our Python program \ttt{apply}, but it's pretty good!
\\ \\
Another cool (but admittedly silly) use case is defining \ttt{length}, which we can simply define as:
\begin{minted}{scheme}
(claim length (Pi ((a U) (k Nat)) (-> (Vec a k) Nat)))
(define length (lambda (a k v) k))
\end{minted}
Similarly, we can define more expressive types for familiar list functions such as \hyperref[code:map]{\ttt{map}} and \hyperref[code:reverse]{\ttt{reverse}} which would express the fact that these do not affect the length of the input list, or \hyperref[code:repeat]{\ttt{repeat}}, whose type would reflect the fact that the length of the output list is the same as the input natural number.
\\ \\
Unfortunately, we can't implement a lot of these quite yet, since the tools we have for iteration/recursion as of right now will not work for \ttt{Vec}.
\subsection{How far can we go with dependent types?}
In this chapter, we saw how the types of \ttt{head} and \ttt{tail} involve the term \ttt{(Vec a (add1 k))}. That \ttt{(add1 k)} can be replaced with any arbitrary program that produces a natural number; so, \textcolor{red}{how can Pie tell if two of these types of expressions are equal if they are written in different ways?}
\\ \\
For example, suppose we have a function \[
    \ttt{(claim double (\(\Pi\) ((a U) (k Nat)) (\(\to\) (Vec a k) (Vec a (+ k k)))))}
\]
and a function \[
    \ttt{(claim un-interleave (\(\Pi\) ((a U) (k Nat)) (\(\to\) (Vec a (* 2 k)) (Pair (Vec a k) (Vec a k)))))}
\]
Would we be able to compose these functions? How can we tell Pie that \ttt{(+ k k)} is the same \ttt{Nat} as \ttt{(* 2 k)}?
\section{It All Depends on the Motive}
\subsection{Summary}
This chapter introduces the \ttt{ind-Nat} eliminator, which allows us to use \ttt{rec-Nat} in situations where the type of the ``almost results" change with each call to the step function. 
\\ \\
This opens up a new class of programs that we couldn't implement before, such as programs that construct or eliminate vectors.
\subsection{The \ttt{ind-Nat} eliminator}
For
\begin{align*}
    \ttt{target} &\quad \text{a \ttt{Nat}} \\
    \ttt{mot} &\quad \text{a \ttt{(\(\to\) Nat \(\mathcal{U}\))}} \\
    \ttt{base} &\quad \text{a \ttt{(mot zero)}} \\
    \ttt{step} &\quad \text{a \ttt{(\(\Pi\) ((k Nat)) (\(\to\) (mot k) (mot (add1 k))))}}
\end{align*}
the expression \(E \coloneqq \ttt{(ind-Nat target mot base step)}\) is a \ttt{(mot target)}.
\\ \\
Furthermore, \(E\) is the same \ttt{(mot zero)} as \ttt{base} when \ttt{target} is zero, and the same \ttt{(mot (add1 n))} as \[
    \ttt{(step n (ind-Nat n mot base step))}
\] when \ttt{target} is \ttt{(add1 n)}.
\\ \\
Roughly, \ttt{ind-Nat} can be used to compute expressions of the form \[
    f_n(n, f_{n - 1}(n-1, f_{n-2}(n - 2, \dots f_0(0, s)\dots)))
\] where \(s \in X_0\) and \(f_k : \bN \times X_k \to X_{k + 1}\). This isn't exactly right, though, as the functions \(f_k\) aren't exactly independent, as the notation might imply, but rather they all have ``roughly the same behaviour". \textcolor{red}{How can we describe this restriction on the sequence of functions more precisely?}
\\ \\
So, we can think of applying \ttt{ind-Nat} to \(n\) as a sort of path through the first \(n + 1\) types in an infinite sequence of types. It seems that not all sequences of types are valid, though; for example, I don't think it is possible to use \ttt{ind-Nat} to traverse the sequence \ttt{Atom, Nat, Atom, Nat, \dots} \textcolor{red}{What kind of sequences are valid?}
\\ \\
In general, \textcolor{red}{what can \ttt{ind-Nat} do and not do? On one hand, it seems like the new \ttt{mot} argument makes \ttt{ind-Nat} significantly stronger, but it feels like there are some subtle restrictions that aren't obvious from the type}.
\subsection{Superfluence of \ttt{rec-Nat} with respect to \ttt{ind-Nat}}
\ttt{rec-Nat} is just \ttt{ind-Nat} with a constant function supplied for \ttt{mot}. This makes sense, as the \ttt{mot} parameter determines the type of \ttt{step} and the ``almost result" at each iteration, which in the case of \ttt{rec-Nat} never changes.
\subsection{Depending on \ttt{ind-Nat}}
\ttt{ind-Nat} is necessary when the type of our computation depends on the natural \ttt{target}; that is, \ttt{ind-Nat} is necessary when we are dealing with dependent types. So far, the only dependent type we have seen is the \ttt{Vec} type. By extension, any type which contains the \ttt{Vec} type, such as pairs of vectors, or functions on vectors, are also dependent.
\\ \\
In particular, \ttt{ind-Nat} is a natural choice when the value of a computation at the \((n + 1)\)'st stage can be expressed in terms of the value at the \(n\)'th stage \textit{and the types of these values are different}. This enables us to write algorithms like \hyperref[code:range]{range},
\newpage
\begin{appendix}
\section{Some Cool Pie Code} \label{pie-code-appendix}
\renewcommand{\contentsname}{\normalsize Contents}
\localtableofcontents
\newpage\noindent
\input{code-listing}
\end{appendix}
\end{document}
