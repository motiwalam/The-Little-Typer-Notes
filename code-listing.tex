\subsubsection{appendvec} \label{code:appendvec}
\begin{minted}{scheme}
(claim appendvec (Pi ((a U) (k Nat)) (-> a (Vec a k) (Vec a (add1 k)))))
(define appendvec
  (lambda (a k e v)
    (ind-Vec k v
      (lambda (i x) (Vec a (add1 i)))
      (vec:: e vecnil)
      (lambda (k-1 e es ces) (vec:: e ces)))))

\subsubsection{reversevec} \label{code:reversevec}
\begin{minted}{scheme}
(claim reversevec (Pi ((a U) (k Nat)) (-> (Vec a k) (Vec a k))))
(define reversevec
  (lambda (a k v)
    (ind-Vec k v
      (lambda (i x) (Vec a i))
      vecnil
      (lambda (k-1 e es ces) (appendvec a k-1 e ces)))))
\end{minted}


\subsection{Control Flow}

\subsubsection{if} \label{code:if}
\begin{minted}{scheme}
; this isn't really a true if as it will always evaluate both branches
; (unless Pie is lazily evaluated) but it doesn't matter because
; Pie doesn't have any side effects 
(claim if (Pi ((a U)) (-> Nat a a a)))
(define if (lambda (a c true false) (which-Nat c false (const a Nat true))))
\end{minted}

\subsubsection{cond} \label{code:cond}
\begin{minted}{scheme}
; the same caveat about evaluation as in "if" applies here
(claim cond (Pi ((a U)) (-> (List (Pair Nat a)) a a)))
(define cond
  (lambda (a cs else)
    (rec-List
      cs
      else
      (lambda (x xs cond-xs) (if a (car x) (cdr x) cond-xs)))))
\end{minted}


\subsection{Miscellaneous programs}

\subsubsection{Fibonacci} \label{code:Fibonacci}
\begin{minted}{scheme}
; we want this function to satisfy
; g(n) = 2^{fib(n)}3^{fib(n + 1)}
; by using lo, we can solve for g(n + 1) in terms of g(n)
; then, fib(n) = lo(2, g(n))
(claim __fib-helper-g UNat)
(define __fib-helper-g
    (lambda (n+1)
        (rec-Nat n+1
            6
            (lambda (n g-n) 
                (*
                    (^ 2 (lo 3 g-n))
                    (^ 3
                       (+ (lo 3 g-n) (lo 2 g-n))))))))

(claim fib UNat)
(define fib (lambda (n) (lo 2 (__fib-helper-g n))))
\end{minted}

\subsubsection{factorial} \label{code:factorial}
\begin{minted}{scheme}
(claim ! UNat)
(define ! (lambda (n) (prod succ (pred n))))
\end{minted}

\subsubsection{prime?} \label{code:prime?}
\begin{minted}{scheme}
(claim prime? UNat)
; p is prime iff p has only 2 divisors, 1 and itself
(define prime? (lambda (p) (== 2 (sum (flip Nat Nat Nat divides? p) p))))
\end{minted}

\subsubsection{nth-prime} \label{code:nth-prime}
\begin{minted}{scheme}
(claim nth-prime UNat)
; given the nth prime, we know the (n + 1)th prime
; is less than or equal to the factorial of the nth prime + 1
; so we can use mu
(define nth-prime
    (lambda (n+1)
        (rec-Nat
            n+1
            2
            (lambda (n pn) 
                (mu (succ (! pn)) 
                    (lambda (z) 
                        (and (prime? z) (> z pn))))))))
\end{minted}

\subsubsection{rec-Nat2 (rec-Nat in terms of iter-Nat)} \label{code:rec-Nat2}
\begin{minted}{scheme}
(claim rec-Nat2 (Pi ((X U)) (-> Nat X (-> Nat X X) X)))
(define rec-Nat2
  (lambda (X target base step)
    (cdr (iter-Nat
           target
           (the (Pair Nat X) (cons 0 base))
           (lambda (p) (cons (succ (car p)) (step (car p) (cdr p))))))))
\end{minted}

\subsubsection{ack (Ackermann function)} \label{code:ack}
\begin{minted}{scheme}
(claim ack (-> Nat Nat Nat))
(define ack
  (lambda (m)
    (iter-Nat
       m
       succ
       (lambda (almost-ack)
         (lambda (n) (iter-Nat (succ n) 1 almost-ack))))))
\end{minted}

\end{minted}

