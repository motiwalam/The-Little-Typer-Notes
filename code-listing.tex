\subsection{Arithmetic}

\subsubsection{successor} \label{code:successor}
\begin{minted}{scheme}
(claim succ UNat)
(define succ (lambda (n) (add1 n)))
\end{minted}

\subsubsection{predecessor} \label{code:predecessor}
\begin{minted}{scheme}
(claim pred UNat)
(define pred (lambda (n) (which-Nat n zero (id Nat))))
\end{minted}

\subsubsection{sgn (1 if n > 0, 0 otherwise)} \label{code:sgn}
\begin{minted}{scheme}
(claim sgn UNat)
(define sgn (lambda (n) (which-Nat n zero ((const Nat Nat) 1))))
\end{minted}

\subsubsection{addition} \label{code:addition}
\begin{minted}{scheme}
(claim + BinNat)
(define + ((iterate-n Nat) succ))
\end{minted}

\subsubsection{subtraction} \label{code:subtraction}
\begin{minted}{scheme}
(claim - BinNat)
(define - ((iterate-n Nat) pred))
\end{minted}

\subsubsection{multiplication} \label{code:multiplication}
\begin{minted}{scheme}
(claim * BinNat)
(define * (lambda (n) ((iterate-n Nat) (+ n) 0)))
\end{minted}

\subsubsection{exponentiation} \label{code:exponentiation}
\begin{minted}{scheme}
(claim ^ BinNat)
(define ^ (lambda (n m) ((iterate-n Nat) (* n) 1 m)))
\end{minted}

\subsubsection{equality} \label{code:equality}
\begin{minted}{scheme}
; output 1 when n = m and 0 otherwise
(claim == BinNat)
(define ==
  (lambda (n m)
    (- 1 (+ (- n m) (- m n)))))

\subsubsection{floordiv} \label{code:floordiv}
\begin{minted}{scheme}
; the idea here is that floor((x + 1)/y) = floor(x/y) unless x + 1 is the next multiple of y
; we know floor(x/y) * y will be the "previous" multiple of y
; so if floor(x/y) * y + y = y(floor(x/y) + 1) = (x + 1), then x + 1 is the "next multiple"
; so, we add 1 to floor(x/y) iff floor(x/y)*y + y = (x + 1)
(claim // BinNat)
(define // 
    ((flip Nat Nat Nat)
        (lambda (y x)
            (rec-Nat x
                0
                (lambda (x-1 d) 
                    (+ d (== (succ x-1) (+ y (* d y)))))))))
\end{minted}

\subsubsection{modulus} \label{code:modulus}
\begin{minted}{scheme}
(claim % BinNat)
(define %
    (lambda (n m) (- n (* m (// n m)))))
\end{minted}

\subsubsection{lo (get exponent of factor)} \label{code:lo}
\begin{minted}{scheme}
(claim lo BinNat)
(define lo
    (lambda (b n)
        (cdr ((iterate-n (Pair Nat Nat))
                (lambda (p)
                    ((the (-> Nat Nat (Pair Nat Nat)) (lambda (i j) 
                        ((the (-> Nat (Pair Nat Nat)) (lambda (div?) 
                            (cons (* div? (// i b)) (+ j (* (sgn i) div?)))))
                         (- 1 (sgn (% i b))))))
                     (car p) (cdr p)))
                (cons n 0)
                n))))
\end{minted}

\end{minted}

\subsection{Miscellaneous programs}

\subsubsection{Fibonacci} \label{code:Fibonacci}
\begin{minted}{scheme}
(claim __fib-helper-g UNat)
(define __fib-helper-g
    (lambda (n+1)
        (rec-Nat n+1
            6
            (lambda (n g-n) 
                (*
                    (^ 2 (lo 3 g-n))
                    (^ 3
                       (+ (lo 3 g-n) (lo 2 g-n))))))))

(claim fib UNat)
(define fib (lambda (n) (lo 2 (__fib-helper-g n))))
\end{minted}


