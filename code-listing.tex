This code listing was generated automatically from \href{https://github.com/thechosenreader/The-Little-Typer-Notes}{\ttt{lib.pie} in this repository}.
\subsection{Types}

\subsubsection{NaryTo} \label{code:NaryTo}
\begin{minted}{scheme}
; creates the type of an n-ary function
; where the arguments are of type a
; and the result is of type b
(claim NaryTo (-> Nat U U U))
(define NaryTo
    (lambda (n a b)
        (iter-Nat n b (lambda (u) (-> a u)))))
\end{minted}

\subsubsection{NaryOp} \label{code:NaryOp}
\begin{minted}{scheme}
; creates the type of an n-ary operation over some type a
(claim NaryOp (-> Nat U U))
(define NaryOp (lambda (n a) (NaryTo n a a)))
\end{minted}

\subsubsection{UNat (unary operator on Nat)} \label{code:UNat}
\begin{minted}{scheme}
(claim UNat U)
(define UNat (NaryOp 1 Nat))
\end{minted}

\subsubsection{Predicate} \label{code:Predicate}
\begin{minted}{scheme}
(claim Predicate (-> U U))
(define Predicate (lambda (a) (-> a Nat)))
\end{minted}

\subsubsection{BinNat (binary operator on Nat)} \label{code:BinNat}
\begin{minted}{scheme}
(claim BinNat U)
(define BinNat (NaryOp 2 Nat))
\end{minted}


\subsection{Combinators}

\subsubsection{S (substitution)} \label{code:S}
\begin{minted}{scheme}
(claim S
    (Pi ((a U) (b U) (c U)) (-> (-> a b c) (-> a b) a c)))
(define S
    (lambda (a b c) (lambda (x y z) (x z (y z)))))
\end{minted}

\subsubsection{K (const)} \label{code:K}
\begin{minted}{scheme}
(claim const
    (Pi ((a U) (b U)) (-> a b a)))
(define const
    (lambda (a b) (lambda (x y) x)))
\end{minted}

\subsubsection{I (identity)} \label{code:I}
\begin{minted}{scheme}
(claim id 
    (Pi ((a U)) (-> a a)))
(define id
    (lambda (a) (lambda (x) x)))
\end{minted}

\subsubsection{C (flip)} \label{code:C}
\begin{minted}{scheme}
(claim flip
    (Pi ((a U) (b U) (c U)) (-> (-> a b c) (-> b a c))))
(define flip
    (lambda (a b c)
        (lambda (f)
            (lambda (x y) (f y x)))))
\end{minted}

\subsubsection{B (compose)} \label{code:B}
\begin{minted}{scheme}
(claim B
    (Pi ((a U) (b U) (c U)) (-> (-> b c) (-> a b) (-> a c))))
(define B
    (lambda (a b c)
        (lambda (f g)
            (lambda (x) (f (g x))))))
\end{minted}

\subsubsection{B1 (compose unary with binary)} \label{code:B1}
\begin{minted}{scheme}
(claim B1
    (Pi ((a U) (b U) (c U) (d U)) (-> (-> c d) (-> a b c) (-> a b d))))
;TODO: is it possible to use the B1 = BBB construction?
(define B1
    (lambda (a b c d)
        (lambda (f g)
            (lambda (x y) (f (g x y))))))
\end{minted}


\subsection{Functional Tools}

\subsubsection{iterate-n} \label{code:iterate-n}
\begin{minted}{scheme}
(claim iterate-n
    (Pi ((a U)) (-> (-> a a) a Nat a)))
(define iterate-n
    (lambda (a)
        (lambda (f s n)
            (iter-Nat n s f))))
\end{minted}

\subsubsection{projection} \label{code:projection}
\begin{minted}{scheme}
(claim __add-argument-end
    (Pi ((k Nat) (a U)) (-> (NaryOp k a) (NaryOp (add1 k) a))))
(define __add-argument-end
    (lambda (k a)
        (ind-Nat
            k
            (lambda (i) (-> (NaryOp i a) (NaryOp (add1 i) a)))
            (lambda (f x) f)
            (lambda (k-1 almost) 
                (lambda (f x) (almost (f x)))))))
; creates an (i + j + 1)-ary function on the type a 
;  which returns its i'th argument (counting from 0)
(claim projection
    (Pi ((i Nat)
         (j Nat)
         (a U))
         ;       this is just the '+' function
         ;       -----------------------------------
        (NaryOp (iterate-n Nat (lambda (n) (add1 n)) (add1 j) i) a)))
(define projection
    (lambda (i j a)
        (ind-Nat
            i
            ;                    this is just the '+' function
            ;                    -----------------------------------
            (lambda (k) (NaryOp (iterate-n Nat (lambda (n) (add1 n)) (add1 j) k) a))
            (ind-Nat
                j
                (lambda (k) (NaryOp (add1 k) a))
                (lambda (x) x)
                (lambda (k-1 almost) (__add-argument-end (add1 k-1) a almost)))
            (lambda (k-1 almost) (lambda (x) almost)))))
\end{minted}

\subsubsection{compose} \label{code:compose}
\begin{minted}{scheme}
; composes a unary function from b to c with a k-ary function from a^k to b
(claim compose
    (Pi 
        ((k Nat)
         (a U)
         (b U)
         (c U))
        (-> (-> b c) (NaryTo k a b) (NaryTo k a c))))
(define compose
    (lambda (k a b c)
        (ind-Nat
            k
            (lambda (i) (-> (-> b c) (NaryTo i a b) (NaryTo i a c)))
            (lambda (f) f)
            (lambda (k-1 compose-k-1)
                (lambda (f g x) (compose-k-1 f (g x))))
            )))
\end{minted}

\subsubsection{args-to-vec} \label{code:args-to-vec}
\begin{minted}{scheme}
; constructs function from a^{k+1} -> (Vec a (k + 1)) which simply collects 
; its arguments into a vector
(claim args->vec
    (Pi 
        ((a U) 
         (k Nat)) 
        (NaryTo k a (Vec a k))))
(define args->vec
    (lambda (a k)
        (ind-Nat
            k
            (lambda (i) (NaryTo i a (Vec a i)))
            vecnil
            (lambda (k-1 g)
                (lambda (x)
                    (compose
                        k-1
                        a (Vec a k-1) (Vec a (add1 k-1))
                        (lambda (v) (vec:: x v))
                        g
                        ))))))

; cleaner alias
(claim make-vec
    (Pi 
        ((a U) 
         (k Nat)) 
        (NaryTo k a (Vec a k))))
(define make-vec args->vec)
\end{minted}

\subsubsection{args-to-lst} \label{code:args-to-lst}
\begin{minted}{scheme}
; constructs function from a^{k+1} -> (List a) which simply collects 
; its arguments into a list
(claim args->lst
  (Pi 
    ((a U) 
     (k Nat)) 
    (NaryTo k a (List a))))
(define args->lst
    (lambda (a k)
        (ind-Nat
            k
            (lambda (i) (NaryTo i a (List a)))
            nil
            (lambda (k-1 g)
                (lambda (x)
                    (compose
                        k-1
                        a (List a) (List a)
                        (lambda (v) (:: x v))
                        g))))))

; this doesn't work cause vec->lst is defined later
;  and i'm too lazy to move stuff around

; (define args->lst
;   (lambda (a k) 
;     (compose k 
;         a (Vec a (add1 k)) (List a) 
;         (vec->lst a (add1 k)) 
;         (args->vec a k))))

; cleaner alias
(claim make-lst
  (Pi 
    ((a U) 
     (k Nat)) 
    (NaryTo k a (List a))))
(define make-lst args->lst)
\end{minted}

\subsubsection{apply+ (vec-to-args)} \label{code:apply+}
\begin{minted}{scheme}
; applies a function from a^{k + 1} -> b to a (Vec a (k + 1))
(claim apply+
    (Pi
        ((a U)
         (b U)
         (k Nat))
        (-> (NaryTo (add1 k) a b) (Vec a (add1 k)) b)))
(define apply+
    (lambda (a b k)
        (ind-Nat
            k
            (lambda (i) (-> (NaryTo (add1 i) a b) (Vec a (add1 i)) b))
            (lambda (g v) (g (head v)))
            (lambda (k-1 apply+k-1)
                (lambda (g v) (apply+k-1 (g (head v)) (tail v)))))))
\end{minted}

\subsubsection{zip-with} \label{code:zip-with}
\begin{minted}{scheme}
(claim zip-with
  (Pi
    ((a U)
     (b U)
     (c U)
     (k Nat))
    (-> (-> a b c) (Vec a k) (Vec b k) (Vec c k))))
(define zip-with
  (lambda (a b c k)
    (ind-Nat
      k
      (lambda (i) (-> (-> a b c) (Vec a i) (Vec b i) (Vec c i)))
      (lambda (f v w) vecnil)
      (lambda (k-1 almost-zip-with)
        (lambda (f v w)
          (vec:: (f (head v) (head w)) (almost-zip-with f (tail v) (tail w))))))))
\end{minted}

\subsubsection{zip (zip-with cons)} \label{code:zip}
\begin{minted}{scheme}
(claim zip
  (Pi
    ((a U)
     (b U)
     (k Nat))
    (-> (Vec a k) (Vec b k) (Vec (Pair a b) k))))
(define zip
  (lambda (a b k)
    (zip-with a b (Pair a b) k (lambda (x y) (cons x y)))))
\end{minted}


\subsection{Utilities}

\subsubsection{successor} \label{code:successor}
\begin{minted}{scheme}
(claim succ UNat)
(define succ (lambda (n) (add1 n)))
\end{minted}

\subsubsection{predecessor} \label{code:predecessor}
\begin{minted}{scheme}
(claim pred UNat)
(define pred (lambda (n) (which-Nat n zero (id Nat))))
\end{minted}

\subsubsection{sgn} \label{code:sgn}
\begin{minted}{scheme}
; 1 if n > 0, 0 otherwise
(claim sgn UNat)
(define sgn (lambda (n) (which-Nat n zero ((const Nat Nat) 1))))
\end{minted}

\subsubsection{cosgn} \label{code:cosgn}
\begin{minted}{scheme}
; 0 if n > 0, 1 otherwise
(claim cosgn UNat)
(define cosgn (lambda (n) (which-Nat n 1 ((const Nat Nat) 0))))
\end{minted}

\subsubsection{mu (bounded minimization)} \label{code:mu}
\begin{minted}{scheme}
; the smallest natural z <= x satisfying p(z), or x + 1 if no such z exists
(claim mu (-> Nat (Predicate Nat) Nat))
(define mu
    (lambda (x p)
        ; start at 0 and increment iff p evaluates to false (i.e 0)
        (iter-Nat x 
            (cosgn (p 0)) ; // 1 if p(0) is false and 0 if p(0) is true
            (lambda (z) ((iterate-n Nat) succ z (cosgn (p z)))))))
\end{minted}


\subsection{Arithmetic \& Comparisons}

\subsubsection{addition} \label{code:addition}
\begin{minted}{scheme}
(claim + BinNat)
(define + ((iterate-n Nat) succ))
\end{minted}

\subsubsection{subtraction} \label{code:subtraction}
\begin{minted}{scheme}
(claim - BinNat)
(define - ((iterate-n Nat) pred))
\end{minted}

\subsubsection{multiplication} \label{code:multiplication}
\begin{minted}{scheme}
(claim * BinNat)
(define * (lambda (n) ((iterate-n Nat) (+ n) 0)))
\end{minted}

\subsubsection{exponentiation} \label{code:exponentiation}
\begin{minted}{scheme}
(claim ^ BinNat)
(define ^ (lambda (n m) ((iterate-n Nat) (* n) 1 m)))
\end{minted}

\subsubsection{equality} \label{code:equality}
\begin{minted}{scheme}
; output 1 when n = m and 0 otherwise
(claim == BinNat)
(define ==
  (lambda (n m)
    ; (n - m) + (m - n) = 0 if n = m
    ; and > 0 otherwise, hence subtracting
    ; it from 1 returns 1 iff n = m
    (- 1 (+ (- n m) (- m n)))))
\end{minted}

\subsubsection{gt} \label{code:gt}
\begin{minted}{scheme}
(claim > BinNat)
(define >
    (lambda (n m) (sgn (- n m))))
\end{minted}

\subsubsection{lt} \label{code:lt}
\begin{minted}{scheme}
(claim < BinNat)
(define <
    (lambda (n m) (sgn (- m n))))
\end{minted}

\subsubsection{gte} \label{code:gte}
\begin{minted}{scheme}
(claim >= BinNat)
(define >=
    (lambda (n m) (cosgn (< n m))))
\end{minted}

\subsubsection{lte} \label{code:lte}
\begin{minted}{scheme}
(claim <= BinNat)
(define <=
    (lambda (n m) (cosgn (> n m))))
\end{minted}

\subsubsection{floordiv} \label{code:floordiv}
\begin{minted}{scheme}
; floor(n/m) is the smallest number z such that (z + 1)m > n
(claim // BinNat)
(define //
    (lambda (n m)
        (mu n (lambda (z) (> (* (succ z) m) n)))))
\end{minted}

\subsubsection{modulus} \label{code:modulus}
\begin{minted}{scheme}
(claim % BinNat)
(define %
    (lambda (n m) (- n (* m (// n m)))))
\end{minted}

\subsubsection{divides?} \label{code:divides?}
\begin{minted}{scheme}
(claim divides? BinNat)
(define divides?
    (lambda (n m) (== 0 (% m n))))
\end{minted}

\subsubsection{lo (get exponent of factor)} \label{code:lo}
\begin{minted}{scheme}
; lo is the b-adic valuation of n
; it is the smallest integer z such that b^(z + 1) does not divide n
(claim lo BinNat)
(define lo
    (lambda (b n) (mu n (lambda (z) (cosgn (divides? (^ b (succ z)) n))))))
\end{minted}

\subsubsection{sum} \label{code:sum}
\begin{minted}{scheme}
; sum a function f from 0 to n
; i.e, f(0) + f(1) + ... + f(n)
(claim sum (-> UNat Nat Nat))
(define sum
    (lambda (f n)
        (rec-Nat n (f 0) (lambda (n-1 s) (+ s (f (succ n-1)))))))
\end{minted}

\subsubsection{prod} \label{code:prod}
\begin{minted}{scheme}
; multiply a function f from 0 to n
; i.e, f(0) * f(1) * ... * f(n)
(claim prod (-> UNat Nat Nat))
(define prod
    (lambda (f n)
        (rec-Nat n (f 0) (lambda (n-1 s) (* s (f (succ n-1)))))))
\end{minted}


\subsection{Logic}

\subsubsection{not} \label{code:not}
\begin{minted}{scheme}
(claim not UNat)
(define not cosgn)
\end{minted}

\subsubsection{and} \label{code:and}
\begin{minted}{scheme}
(claim and BinNat)
(define and *)
\end{minted}

\subsubsection{or} \label{code:or}
\begin{minted}{scheme}
(claim or BinNat)
(define or
    (lambda (p q) (sgn (+ p q))))
\end{minted}

\subsubsection{xor} \label{code:xor}
\begin{minted}{scheme}
(claim xor BinNat)
(define xor
    (lambda (p q) (== 1 (+ p q))))
\end{minted}


\subsection{Lists}

\subsubsection{prepend (:: or cons)} \label{code:prepend}
\begin{minted}{scheme}
(claim prepend (Pi ((a U)) (-> a (List a) (List a))))
(define prepend (lambda (a x xs) (:: x xs)))
\end{minted}

\subsubsection{snoc (flip append)} \label{code:snoc}
\begin{minted}{scheme}
(claim snoc (Pi ((a U)) (-> (List a) a (List a))))
(define snoc
    (lambda (a)
        (lambda (lst e)
            (rec-List
                lst
                (:: e nil)
                (lambda (x xs snoc-xs) (:: x snoc-xs))))))

(claim append (Pi ((a U)) (-> a (List a) (List a))))
(define append (lambda (a) (flip (List a) a (List a) (snoc a))))
\end{minted}


\subsubsection{length} \label{code:length}
\begin{minted}{scheme}
(claim length (Pi ((a U)) (-> (List a) Nat)))
(define length
    (lambda (a)
        (lambda (lst)
            (rec-List
                lst
                0
                (lambda (e es les) (succ les))))))
\end{minted}

\subsubsection{concat} \label{code:concat}
\begin{minted}{scheme}
(claim concat (Pi ((a U)) (NaryOp 2 (List a))))
(define concat
    (lambda (a)
        (lambda (l1 l2)
            (rec-List
                l1
                l2
                (lambda (x xs concat-xs) (:: x concat-xs))))))
\end{minted}

\subsubsection{reverse} \label{code:reverse}
\begin{minted}{scheme}
(claim reverse (Pi ((a U)) (NaryOp 1 (List a))))
(define reverse
    (lambda (a lst)
        (rec-List lst
            (the (List a) nil)
            (lambda (x xs reverse-xs) (snoc a reverse-xs x)))))
\end{minted}

\subsubsection{map} \label{code:map}
\begin{minted}{scheme}
(claim map (Pi ((a U) (b U)) (-> (-> a b) (List a) (List b))))
(define map
    (lambda (a b f lst)
        (rec-List
            lst
            (the (List b) nil)
            (lambda (x xs map-xs) (:: (f x) map-xs)))))
\end{minted}

\subsubsection{filter} \label{code:filter}
\begin{minted}{scheme}
(claim filter (Pi ((a U)) (-> (Predicate a) (List a) (List a))))
(define filter
    (lambda (a p lst)
        (rec-List
            lst
            (the (List a) nil)
            (lambda (x xs filter-xs)
                (which-Nat (p x) filter-xs (lambda (n) (:: x filter-xs)))))))
\end{minted}

\subsubsection{foldr} \label{code:foldr}
\begin{minted}{scheme}
(claim foldr (Pi ((a U) (b U)) (-> (-> a b b) b (List a) b)))
(define foldr
    (lambda (a b f s l)
        (rec-List 
            l
            s
            (lambda (x xs fold-xs) (f x fold-xs)))))
\end{minted}

\subsubsection{foldl} \label{code:foldl}
\begin{minted}{scheme}
(claim foldl (Pi ((a U) (b U)) (-> (-> b a b) b (List a) b)))
(define foldl
    (lambda (a b f s l) (foldr a b (flip b a b f) s (reverse a l))))
\end{minted}

\subsubsection{repeat} \label{code:repeat}
\begin{minted}{scheme}
(claim repeat (Pi ((a U)) (-> Nat a (List a))))
(define repeat
    (lambda (a k x) (iterate-n (List a) (prepend a x) (the (List a) nil) k)))
\end{minted}


\subsubsection{lst-to-vec} \label{code:lst-to-vec}
\begin{minted}{scheme}
(claim lst->vec (Pi ((a U) (lst (List a))) (Vec a (length a lst))))
(define lst->vec
  (lambda (a lst)
    (ind-List
      lst
      (lambda (i) (Vec a (length a i)))
      vecnil
      (lambda (x xs vxs) (vec:: x vxs)))))
\end{minted}

\subsection{Vectors}

\subsubsection{repeatvec} \label{code:repeatvec}
\begin{minted}{scheme}
(claim repeatvec
  (Pi ((a U) (k Nat)) (-> a (Vec a k))))
(define repeatvec
  (lambda (a k e)
    (ind-Nat
      k
      (lambda (i) (Vec a i))
      vecnil
      (lambda (k-1 almost) (vec:: e almost)))))
\end{minted}

\subsubsection{vec-to-lst} \label{code:vec-to-lst}
\begin{minted}{scheme}
(claim vec->lst (Pi ((a U) (k Nat)) (-> (Vec a k) (List a))))
(define vec->lst
  (lambda (a k v)
    (ind-Vec k v
      (lambda (j w) (List a))
      nil
      (lambda (k-1 e es les) (:: e les)))))
\end{minted}

\subsubsection{drop} \label{code:drop}
\begin{minted}{scheme}
; remove first n elements from a vector of length n + k
(claim drop (Pi ((a U) (n Nat) (k Nat)) (-> (Vec a (+ k n)) (Vec a k))))
(define drop
  (lambda (a n k)
    (ind-Nat
      n
      (lambda (i) (-> (Vec a (+ k i)) (Vec a k)))
      (lambda (x) x)
      (lambda (n-1 f) (lambda (w) (f (tail w)))))))
\end{minted}

\subsubsection{nth-element} \label{code:nth-element}
\begin{minted}{scheme}
(claim nth-element (Pi ((a U) (i Nat) (k Nat)) (-> (Vec a (+ (add1 k) i)) a)))
(define nth-element
  (lambda (a i k v) (head (drop a i (add1 k) v))))
\end{minted}

\subsubsection{range} \label{code:range}
\begin{minted}{scheme}
; the sequence (0, ..., k-1)
(claim range (Pi ((k Nat)) (Vec Nat k)))
(define range
  (lambda (k)
    (ind-Nat
      k
      (lambda (n) (Vec Nat n))
      vecnil
      (lambda (k-1 rk-1) (vec:: (- k (succ k-1)) rk-1)))))

; the sequence (s, ..., e-1)
(claim range2 (Pi ((s Nat) (e Nat)) (Vec Nat (- e s))))
; (- m n) == 0 for n >= m
(define range2
  (lambda (s e)
    (ind-Nat
      (- e s)
      (lambda (n) (Vec Nat n))
      vecnil
      (lambda (k-1 rk-1) (vec:: (- e (succ k-1)) rk-1)))))

; the sequence {s + kst : k \in N, s + kst < e} (ordered by k)
(claim range3 (Pi ((s Nat) (e Nat) (st Nat)) (Vec Nat (succ (// (- e (succ s)) st)))))
(define range3
  (lambda (s e st)
    (ind-Nat
      (succ (// (- e (succ s)) st))
      (lambda (n) (Vec Nat n))
      vecnil
      (lambda (k-1 rk-1) (vec:: (+ s (* st (- (succ (// (- e (succ s)) st)) (succ k-1)))) rk-1)))))
\end{minted}

\subsubsection{mapvec} \label{code:mapvec}
\begin{minted}{scheme}
(claim mapvec (Pi ((a U) (b U) (k Nat)) (-> (-> a b) (Vec a k) (Vec b k))))
(define mapvec
  (lambda (a b k f v)
    (ind-Vec k v
      (lambda (j v) (Vec b j))
      vecnil
      (lambda (k-1 e es mes) (vec:: (f e) mes)))))
\end{minted}

\subsubsection{concatvec} \label{code:concatvec}
\begin{minted}{scheme}
(claim concatvec (Pi ((a U) (k Nat) (j Nat)) (-> (Vec a k) (Vec a j) (Vec a (+ j k)))))
(define concatvec
  (lambda (a k j v w)
    (ind-Vec k v
      (lambda (i x) (Vec a (+ j i)))
      w
      (lambda (k-1 e es ces) (vec:: e ces)))))
\end{minted}

\subsubsection{appendvec} \label{code:appendvec}
\begin{minted}{scheme}
(claim appendvec (Pi ((a U) (k Nat)) (-> a (Vec a k) (Vec a (add1 k)))))
(define appendvec
  (lambda (a k e v)
    (ind-Vec k v
      (lambda (i x) (Vec a (add1 i)))
      (vec:: e vecnil)
      (lambda (k-1 e es ces) (vec:: e ces)))))
\end{minted}

\subsubsection{reversevec} \label{code:reversevec}
\begin{minted}{scheme}
(claim reversevec (Pi ((a U) (k Nat)) (-> (Vec a k) (Vec a k))))
(define reversevec
  (lambda (a k v)
    (ind-Vec k v
      (lambda (i x) (Vec a i))
      vecnil
      (lambda (k-1 e es ces) (appendvec a k-1 e ces)))))
\end{minted}

\subsubsection{transpose} \label{code:transpose}
\begin{minted}{scheme}
(claim transpose
  (Pi ((m Nat)
       (n Nat)
       (a U))
    (-> (Vec (Vec a n) m) (Vec (Vec a m) n))))
(define transpose
  (lambda (m n a)
    (ind-Nat
      m
      (lambda (i) (-> (Vec (Vec a n) i) (Vec (Vec a i) n)))
      (lambda (M) (repeatvec (Vec a 0) n vecnil))
      (lambda (m-1 almost-transpose)
        (lambda (M)
          (zip-with
            a (Vec a m-1) (Vec a (add1 m-1))
            n
            (lambda (x row) (vec:: x row))
            (head M)
            (almost-transpose (tail M))))))))
; alternate approach inspired by the python code
;  transpose = lambda mat: tuple(zip(*mat))
(claim transpose2
  (Pi ((m Nat)
       (n Nat)
       (a U))
    (-> (Vec (Vec a n) m) (Vec (Vec a m) n))))
(define transpose2
  (lambda (m n a v)
    (ind-Vec
      m
      v
      (lambda (i v) (Vec (Vec a i) n))
      (repeatvec (Vec a 0) n vecnil)
      (lambda (k-1 r rs almost)
        (zip-with a (Vec a k-1) (Vec a (add1 k-1)) n 
            (lambda (e x) (vec:: e x)) 
            r almost)))))
\end{minted}



\subsection{Control Flow}

\subsubsection{if} \label{code:if}
\begin{minted}{scheme}
; this isn't really a true if as it will always evaluate both branches
; (unless Pie is lazily evaluated) but it doesn't matter because
; Pie doesn't have any side effects 
(claim if (Pi ((a U)) (-> Nat a a a)))
(define if (lambda (a c true false) (which-Nat c false (const a Nat true))))
\end{minted}

\subsubsection{cond} \label{code:cond}
\begin{minted}{scheme}
; the same caveat about evaluation as in "if" applies here
(claim cond (Pi ((a U)) (-> (List (Pair Nat a)) a a)))
(define cond
  (lambda (a cs else)
    (rec-List
      cs
      else
      (lambda (x xs cond-xs) (if a (car x) (cdr x) cond-xs)))))
\end{minted}


\subsection{Proofs}

\subsubsection{+associates} \label{code:+associates}
\begin{minted}{scheme}
; proof that (+ a (+ b c)) = (+ (+ a b) c) for all a, b, c in Nat
(claim +associates
  (Pi ((a Nat) (b Nat) (c Nat))
    (= Nat (+ a (+ b c)) (+ (+ a b) c))))
(define +associates
  (lambda (a b c)
    (ind-Nat
      c
      (lambda (i) (= Nat (+ a (+ b i)) (+ (+ a b) i)))
      (same (+ a b))
      (lambda (k-1 almost)
        (cong almost succ)))))
\end{minted}

\subsubsection{+commutes} \label{code:+commutes}
\begin{minted}{scheme}
; proof that (+ m n) = (+ n m) for all m, n in Nat
(claim +0-commutes
  (Pi ((m Nat)) (= Nat (+ m 0) (+ 0 m))))
(define +0-commutes
  (lambda (m)
    (ind-Nat
      m
      (lambda (i) (= Nat (+ i 0) (+ 0 i)))
      (same 0)
      (lambda (k-1 almost) (cong almost succ)))))

(claim +1-associates
  (Pi ((m Nat) (n Nat))
    (= Nat (+ (add1 m) n) (+ m (add1 n)))))
(define +1-associates
  (lambda (m n)
    (ind-Nat
      n
      (lambda (i) (= Nat (+ (add1 m) i) (+ m (add1 i))))
      (same (add1 m))
      (lambda (n-1 almost)
        (cong almost succ)))))

(claim +commutes
  (Pi ((m Nat) (n Nat)) (= Nat (+ m n) (+ n m))))
(define +commutes
  (lambda (m n)
    (ind-Nat
      n
      (lambda (i) (= Nat (+ m i) (+ i m)))
      (+0-commutes m)
      (lambda (k-1 almost)
        (trans
         (cong almost succ)
         (symm (+1-associates k-1 m)))))))
\end{minted}


\subsection{Miscellaneous programs}

\subsubsection{Fibonacci} \label{code:Fibonacci}
\begin{minted}{scheme}
; we want this function to satisfy
; g(n) = 2^{fib(n)}3^{fib(n + 1)}
; by using lo, we can solve for g(n + 1) in terms of g(n)
; then, fib(n) = lo(2, g(n))
(claim __fib-helper-g UNat)
(define __fib-helper-g
    (lambda (n+1)
        (rec-Nat n+1
            6
            (lambda (n g-n) 
                (*
                    (^ 2 (lo 3 g-n))
                    (^ 3
                       (+ (lo 3 g-n) (lo 2 g-n))))))))

(claim fib UNat)
(define fib (lambda (n) (lo 2 (__fib-helper-g n))))
\end{minted}

\subsubsection{factorial} \label{code:factorial}
\begin{minted}{scheme}
(claim ! UNat)
(define ! (lambda (n) (prod succ (pred n))))
\end{minted}

\subsubsection{prime?} \label{code:prime?}
\begin{minted}{scheme}
(claim prime? UNat)
; p is prime iff p has only 2 divisors, 1 and itself
(define prime? (lambda (p) (== 2 (sum (flip Nat Nat Nat divides? p) p))))
\end{minted}

\subsubsection{nth-prime} \label{code:nth-prime}
\begin{minted}{scheme}
(claim nth-prime UNat)
; given the nth prime, we know the (n + 1)th prime
; is less than or equal to the factorial of the nth prime + 1
; so we can use mu
(define nth-prime
    (lambda (n+1)
        (rec-Nat
            n+1
            2
            (lambda (n pn) 
                (mu (succ (! pn)) 
                    (lambda (z) 
                        (and (prime? z) (> z pn))))))))
\end{minted}

\subsubsection{rec-Nat2 (rec-Nat in terms of iter-Nat)} \label{code:rec-Nat2}
\begin{minted}{scheme}
(claim rec-Nat2 (Pi ((X U)) (-> Nat X (-> Nat X X) X)))
(define rec-Nat2
  (lambda (X target base step)
    (cdr (iter-Nat
           target
           (the (Pair Nat X) (cons 0 base))
           (lambda (p) (cons (succ (car p)) (step (car p) (cdr p))))))))
\end{minted}

\subsubsection{ack (Ackermann function)} \label{code:ack}
\begin{minted}{scheme}
(claim ack (-> Nat Nat Nat))
(define ack
  (lambda (m)
    (iter-Nat
       m
       succ
       (lambda (almost-ack)
         (lambda (n) (iter-Nat (succ n) 1 almost-ack))))))
\end{minted}


\subsubsection{PairVec (the Vec type implemented with Pairs)} \label{code:PairVec}
\begin{minted}{scheme}
; PairVec ~ Vec
; (PairVec a k) is a list of k a's
; it gets expanded as (Pair a (Pair a (Pair a ... (k times) Trivial)))
(claim PairVec
  (Pi ((a U) (k Nat)) U))
(define PairVec
  (lambda (a k)
    (iter-Nat k
      Trivial ; (PairVec a 0) is Trivial
      (lambda (u) (Pair a u)))))

; pvnil is the constructor for (PairVec a 0)
(claim pv.nil Trivial)
(define pv.nil sole)

; pv:: is identical to the builtin cons
(claim pv:: (Pi ((a U) (k Nat)) (-> a (PairVec a k) (PairVec a (add1 k)))))
(define pv::
  (lambda (a k e p) (cons e p)))

; pv.head is identical to the builtin car
(claim pv.head
  (Pi ((a U) (k Nat)) (-> (PairVec a (add1 k)) a)))
(define pv.head
  (lambda (a k p) (car p)))

; pv.tail is identical to the builtin cdr
(claim pv.tail
  (Pi ((a U) (k Nat)) (-> (PairVec a (add1 k)) (PairVec a k))))
(define pv.tail
  (lambda (a k p) (cdr p)))

; a copy of the type of ind-Vec from the Pie reference
(claim ind-PairVec
  (Pi ((E U)
       (target-1 Nat)
       (target-2 (PairVec E target-1))
       (motive (Pi ((k Nat)) (-> (PairVec E k) U)))
       (base (motive zero pv.nil))
       (step (Pi ((k Nat)
                  (e E)
                  (es (PairVec E k)))
                  (-> (motive k es) (motive (add1 k) (cons e es))))))
    (motive target-1 target-2)))
; we use induction to create a function that can inductively eliminate
; a k+1-length PairVec from a function that can inductively eliminate
; a k-length Pairvec
(define ind-PairVec
    (lambda (E target-1 target-2 motive base step)
        ((ind-Nat
            target-1
            (lambda (i) (Pi ((w (PairVec E i))) (motive i w)))
            (lambda (w) base)
            (lambda (k-1 almost-ind)
                (lambda (w)
                    (step k-1 (car w) (cdr w) (almost-ind (cdr w))))))
        target-2)))
\end{minted}


