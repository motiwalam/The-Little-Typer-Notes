#lang pie

;;;;;;;;;;;;;;;
;@begin section Types
;;;;;;;;;;;;;;;

;@begin code NaryOp
; creates the type of an n-ary operation over some type a
(claim NaryOp (-> Nat U U))
(define NaryOp
    (lambda (n a)
        (iter-Nat n a (lambda (u) (-> a u)))))
;@end

;@begin code UNat (unary operator on Nat)
(claim UNat U)
(define UNat (NaryOp 1 Nat))
;@end

;@begin code Predicate 
(claim Predicate (-> U U))
(define Predicate (lambda (a) (-> a Nat)))
;@end

;@begin code BinNat (binary operator on Nat)
(claim BinNat U)
(define BinNat (NaryOp 2 Nat))
;@end

;@end // section Types

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@begin section Combinators
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;@begin code S (substitution)
(claim S
    (Pi ((a U) (b U) (c U)) (-> (-> a b c) (-> a b) a c)))
(define S
    (lambda (a b c) (lambda (x y z) (x z (y z)))))
;@end

;@begin code K (const)
(claim const
    (Pi ((a U) (b U)) (-> a b a)))
(define const
    (lambda (a b) (lambda (x y) x)))
;@end

;@begin code I (identity)
(claim id 
    (Pi ((a U)) (-> a a)))
(define id
    (lambda (a) (lambda (x) x)))
;@end

;@begin code C (flip)
(claim flip
    (Pi ((a U) (b U) (c U)) (-> (-> a b c) (-> b a c))))
(define flip
    (lambda (a b c)
        (lambda (f)
            (lambda (x y) (f y x)))))
;@end

;@begin code B (compose)
(claim B
    (Pi ((a U) (b U) (c U)) (-> (-> b c) (-> a b) (-> a c))))
(define B
    (lambda (a b c)
        (lambda (f g)
            (lambda (x) (f (g x))))))
;@end

;@begin code B1 (compose unary with binary)
(claim B1
    (Pi ((a U) (b U) (c U) (d U)) (-> (-> c d) (-> a b c) (-> a b d))))
;TODO: is it possible to use the B1 = BBB construction?
(define B1
    (lambda (a b c d)
        (lambda (f g)
            (lambda (x y) (f (g x y))))))
;@end

;@end // section Combinators

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@begin section Functional Tools
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;@begin code iterate-n
(claim iterate-n
    (Pi ((a U)) (-> (-> a a) a Nat a)))
(define iterate-n
    (lambda (a)
        (lambda (f s n)
            (iter-Nat n s f))))
;@end

;@end // section Functional Tools

;;;;;;;;;;;;;;;;;;;;;;;;;
;@begin section Utilities
;;;;;;;;;;;;;;;;;;;;;;;;;

;@begin code successor
(claim succ UNat)
(define succ (lambda (n) (add1 n)))
;@end

;@begin code predecessor
(claim pred UNat)
(define pred (lambda (n) (which-Nat n zero (id Nat))))
;@end

;@begin code sgn
; 1 if n > 0, 0 otherwise
(claim sgn UNat)
(define sgn (lambda (n) (which-Nat n zero ((const Nat Nat) 1))))
;@end

;@begin code cosgn
; 0 if n > 0, 1 otherwise
(claim cosgn UNat)
(define cosgn (lambda (n) (which-Nat n 1 ((const Nat Nat) 0))))
;@end

;@begin code mu (bounded minimization)
; the smallest natural z <= x satisfying p(z), or x + 1 if no such z exists
(claim mu (-> Nat (Predicate Nat) Nat))
(define mu
    (lambda (x p)
        ; start at 0 and increment iff p evaluates to false (i.e 0)
        (iter-Nat x 
            (cosgn (p 0)) ; // 1 if p(0) is false and 0 if p(0) is true
            (lambda (z) ((iterate-n Nat) succ z (cosgn (p z)))))))
;@end

;@end // section Utilities

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@begin section Arithmetic \& Comparisons
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;@begin code addition
(claim + BinNat)
(define + ((iterate-n Nat) succ))
;@end

;@begin code subtraction
(claim - BinNat)
(define - ((iterate-n Nat) pred))
;@end

;@begin code multiplication
(claim * BinNat)
(define * (lambda (n) ((iterate-n Nat) (+ n) 0)))
;@end

;@begin code exponentiation
(claim ^ BinNat)
(define ^ (lambda (n m) ((iterate-n Nat) (* n) 1 m)))
;@end

;@begin code equality
; output 1 when n = m and 0 otherwise
(claim == BinNat)
(define ==
  (lambda (n m)
    ; (n - m) + (m - n) = 0 if n = m
    ; and > 0 otherwise, hence subtracting
    ; it from 1 returns 1 iff n = m
    (- 1 (+ (- n m) (- m n)))))
;@end

;@begin code gt
(claim > BinNat)
(define >
    (lambda (n m) (sgn (- n m))))
;@end

;@begin code lt
(claim < BinNat)
(define <
    (lambda (n m) (sgn (- m n))))
;@end

;@begin code gte
(claim >= BinNat)
(define >=
    (lambda (n m) (cosgn (< n m))))
;@end

;@begin code lte
(claim <= BinNat)
(define <=
    (lambda (n m) (cosgn (> n m))))
;@end

;@begin code floordiv
; floor(n/m) is the smallest number z such that (z + 1)m > n
(claim // BinNat)
(define //
    (lambda (n m)
        (mu n (lambda (z) (> (* (succ z) m) n)))))
;@end

;@begin code modulus
(claim % BinNat)
(define %
    (lambda (n m) (- n (* m (// n m)))))
;@end

;@begin code divides
(claim divides? BinNat)
(define divides?
    (lambda (n m) (== 0 (% m n))))
;@end

;@begin code lo (get exponent of factor)
; lo is the b-adic valuation of n
; it is the smallest integer z such that b^(z + 1) does not divide n
(claim lo BinNat)
(define lo
    (lambda (b n) (mu n (lambda (z) (cosgn (divides? (^ b (succ z)) n))))))
;@end

;@begin code sum
; sum a function f from 0 to n
; i.e, f(0) + f(1) + ... + f(n)
(claim sum (-> UNat Nat Nat))
(define sum
    (lambda (f n)
        (rec-Nat n (f 0) (lambda (n-1 s) (+ s (f (succ n-1)))))))
;@end

;@begin code prod
; multiply a function f from 0 to n
; i.e, f(0) * f(1) * ... * f(n)
(claim prod (-> UNat Nat Nat))
(define prod
    (lambda (f n)
        (rec-Nat n (f 0) (lambda (n-1 s) (* s (f (succ n-1)))))))
;@end

;@end // section Arithmetic

;;;;;;;;;;;;;;;;;;;;;
;@begin section Logic
;;;;;;;;;;;;;;;;;;;;;

;@begin code not
(claim not UNat)
(define not cosgn)
;@end

;@begin code and
(claim and BinNat)
(define and *)
;@end

;@begin code or
(claim or BinNat)
(define or
    (lambda (p q) (sgn (+ p q))))
;@end

;@begin code xor
(claim xor BinNat)
(define xor
    (lambda (p q) (== 1 (+ p q))))
;@end

;@end // section logic

;;;;;;;;;;;;;;;;;;;;;
;@begin section Lists
;;;;;;;;;;;;;;;;;;;;;

;@begin code prepend (:: or cons)
(claim prepend (Pi ((a U)) (-> a (List a) (List a))))
(define prepend (lambda (a x xs) (:: x xs)))
;@end

;@begin code snoc (flip append)
(claim snoc (Pi ((a U)) (-> (List a) a (List a))))
(define snoc
    (lambda (a)
        (lambda (lst e)
            (rec-List
                lst
                (:: e nil)
                (lambda (x xs snoc-xs) (:: x snoc-xs))))))

(claim append (Pi ((a U)) (-> a (List a) (List a))))
(define append (lambda (a) (flip (List a) a (List a) (snoc a))))
;@end


;@begin code length
(claim length (Pi ((a U)) (-> (List a) Nat)))
(define length
    (lambda (a)
        (lambda (lst)
            (rec-List
                lst
                0
                (lambda (e es les) (succ les))))))
;@end

;@begin code concat
(claim concat (Pi ((a U)) (NaryOp 2 (List a))))
(define concat
    (lambda (a)
        (lambda (l1 l2)
            (rec-List
                l1
                l2
                (lambda (x xs concat-xs) (:: x concat-xs))))))
;@end

;@begin code reverse
(claim reverse (Pi ((a U)) (NaryOp 1 (List a))))
(define reverse
    (lambda (a lst)
        (rec-List lst
            (the (List a) nil)
            (lambda (x xs reverse-xs) (snoc a reverse-xs x)))))
;@end

;@begin code map
(claim map (Pi ((a U) (b U)) (-> (-> a b) (List a) (List b))))
(define map
    (lambda (a b f lst)
        (rec-List
            lst
            (the (List b) nil)
            (lambda (x xs map-xs) (:: (f x) map-xs)))))
;@end

;@begin code filter
(claim filter (Pi ((a U)) (-> (Predicate a) (List a) (List a))))
(define filter
    (lambda (a p lst)
        (rec-List
            lst
            (the (List a) nil)
            (lambda (x xs filter-xs)
                (which-Nat (p x) filter-xs (lambda (n) (:: x filter-xs)))))))
;@end

;@begin code foldr
(claim foldr (Pi ((a U) (b U)) (-> (-> a b b) b (List a) b)))
(define foldr
    (lambda (a b f s l)
        (rec-List 
            l
            s
            (lambda (x xs fold-xs) (f x fold-xs)))))
;@end

;@begin code foldl
(claim foldl (Pi ((a U) (b U)) (-> (-> b a b) b (List a) b)))
(define foldl
    (lambda (a b f s l) (foldr a b (flip b a b f) s (reverse a l))))
;@end

;@begin code repeat
(claim repeat (Pi ((a U)) (-> Nat a (List a))))
(define repeat
    (lambda (a k x) (iterate-n (List a) (prepend a x) (the (List a) nil) k)))
;@end

;@end // section Lists

;;;;;;;;;;;;;;;;;;;;
;@begin section Control Flow
;;;;;;;;;;;;;;;;;;;;

;@begin code if
; this isn't really a true if as it will always evaluate both branches
; (unless Pie is lazily evaluated) but it doesn't matter because
; Pie doesn't have any side effects 
(claim if (Pi ((a U)) (-> Nat a a a)))
(define if (lambda (a c true false) (which-Nat c false (const a Nat true))))
;@end

;@begin code cond
; the same caveat about evaluation as in "if" applies here
(claim cond (Pi ((a U)) (-> (List (Pair Nat a)) a a)))
(define cond
  (lambda (a cs else)
    (rec-List
      cs
      else
      (lambda (x xs cond-xs) (if a (car x) (cdr x) cond-xs)))))
;@end

;@end // section Control Flow

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@begin section Miscellaneous programs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;@begin code Fibonacci
; we want this function to satisfy
; g(n) = 2^{fib(n)}3^{fib(n + 1)}
; by using lo, we can solve for g(n + 1) in terms of g(n)
; then, fib(n) = lo(2, g(n))
(claim __fib-helper-g UNat)
(define __fib-helper-g
    (lambda (n+1)
        (rec-Nat n+1
            6
            (lambda (n g-n) 
                (*
                    (^ 2 (lo 3 g-n))
                    (^ 3
                       (+ (lo 3 g-n) (lo 2 g-n))))))))

(claim fib UNat)
(define fib (lambda (n) (lo 2 (__fib-helper-g n))))
;@end

;@begin code factorial
(claim ! UNat)
(define ! (lambda (n) (prod succ (pred n))))
;@end

;@begin code prime?
(claim prime? UNat)
; p is prime iff p has only 2 divisors, 1 and itself
(define prime? (lambda (p) (== 2 (sum (flip Nat Nat Nat divides? p) p))))
;@end

;@begin code nth-prime
(claim nth-prime UNat)
; given the nth prime, we know the (n + 1)th prime
; is less than or equal to the factorial of the nth prime + 1
; so we can use mu
(define nth-prime
    (lambda (n+1)
        (rec-Nat
            n+1
            2
            (lambda (n pn) 
                (mu (succ (! pn)) 
                    (lambda (z) 
                        (and (prime? z) (> z pn))))))))
;@end

;@end // section Miscellaneous programs

